[{"path":"https://kennethataylor.github.io/mccount/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 mccount authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/choosing-between-methods.html","id":"two-approaches-same-goal","dir":"Articles","previous_headings":"","what":"Two Approaches, Same Goal","title":"Choosing Between Methods","text":"mccount implements two methods calculating mean cumulative count (MCC): Equation method: Direct calculation using Dong-Yasui estimator SCI method: Sum cumulative incidences approach estimate parameter mathematically equivalent specific conditions. conditions two estimators differ, choice two estimators made based research question hand, specifically characteristics outcome.","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/choosing-between-methods.html","id":"when-methods-are-equivalent","dir":"Articles","previous_headings":"","what":"When Methods Are Equivalent","title":"Choosing Between Methods","text":"MCC estimators yield identical results specific conditions:","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/choosing-between-methods.html","id":"administrative-censoring-only","dir":"Articles","previous_headings":"When Methods Are Equivalent","what":"Administrative Censoring Only","title":"Choosing Between Methods","text":"methods mathematically equivalent censoring except end study follow-(.e. administrative censoring ) - , observe participants either experience competing risk reach end study follow-.","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/choosing-between-methods.html","id":"synchronized-event-interval-censoring","dir":"Articles","previous_headings":"When Methods Are Equivalent","what":"Synchronized Event-Interval Censoring","title":"Choosing Between Methods","text":"Even censoring end follow-, two methods yield identical results censoring follows specific pattern. Censoring must occur everyone remaining risk experienced pth event, anyone (p+1)th. censoring pattern observed non-administrative censoring observed time intervals event count sequence synchronized cohort level. like call pattern synchronized event-interval censoring. Take applied example given Dong, et al.1 - assume 5 participants enrolled hypothetical study: Subject 1: alive end follow-administratively censored time (t8) Subject 2: Lost follow-censored t1 Subject 3: Died (competing-risk event) t5 Subject 4: Experience event interest t2, t6, t7 alive end follow-(administratively censored t8) Subject 5: Experienced event interest t3 died (competing risk event) time point example, methods equivalent non-administrative censoring happens everyone’s first event (.e., synchronized event-interval censoring):","code":"df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2)  )  # Calculating MCC using both estimators mcc_eq <- mcc(   df,   id_var = \"id\",   time_var = \"time\",   cause_var = \"cause\",   method = \"equation\" ) #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  mcc_sci <- mcc(   df,   id_var = \"id\",   time_var = \"time\",   cause_var = \"cause\",   method = \"sci\" ) #> ℹ Adjusted time points for events occurring simultaneously for the same subject. # Dong-Yasui estimator mcc_details(mcc_eq) #> # A tibble: 9 × 8 #>    time nrisk censor event cmprk overall_surv_previous ave_events   mcc #>   <dbl> <dbl>  <dbl> <dbl> <dbl>                 <dbl>      <dbl> <dbl> #> 1  0        5      0     0     0                  1          0     0    #> 2  1        5      1     0     0                  1          0     0    #> 3  2        4      0     1     0                  1          0.25  0.25 #> 4  3        4      0     1     0                  1          0.25  0.5  #> 5  3.00     4      0     0     1                  1          0     0.5  #> 6  5        3      0     0     1                  0.75       0     0.5  #> 7  6        2      0     1     0                  0.5        0.25  0.75 #> 8  7        2      0     1     0                  0.5        0.25  1    #> 9  8        2      2     0     0                  0.5        0     1  # Sum of cumulative incidences estimator mcc_details(mcc_sci) #> # A tibble: 9 × 5 #>    time   CI1   CI2   CI3 SumCIs #>   <dbl> <dbl> <dbl> <dbl>  <dbl> #> 1  0     0     0     0      0    #> 2  1     0     0     0      0    #> 3  2     0.25  0     0      0.25 #> 4  3     0.5   0     0      0.5  #> 5  3.00  0.5   0     0      0.5  #> 6  5     0.5   0     0      0.5  #> 7  6     0.5   0.25  0      0.75 #> 8  7     0.5   0.25  0.25   1    #> 9  8     0.5   0.25  0.25   1"},{"path":"https://kennethataylor.github.io/mccount/articles/choosing-between-methods.html","id":"when-methods-differ-and-why","dir":"Articles","previous_headings":"","what":"When Methods Differ and Why","title":"Choosing Between Methods","text":"results two estimators differ, reflects handle fundamental question outcome: event order matter outcome? Dong-Yasui estimator treats events exchangeable - someone censored 2nd event, affects calculation future events regardless whether 1st, 2nd, 3rd people. SCI method takes event-specific approach - someone censored 2nd event, affects calculations 3rd+ events, 1st/2nd events others.","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/choosing-between-methods.html","id":"when-events-are-exchangeable","dir":"Articles","previous_headings":"When Methods Differ and Why","what":"When Events Are Exchangeable","title":"Choosing Between Methods","text":"Recurrent events healthcare context might reasonably considered exchangeable ordering irrelevant clinically biologically events represent underlying process routine, maintenance-type activities clinical meaning unrelated order recurrent event count. Consider following examples: Routine medication refills: refill chronic medications (blood pressure pills, diabetes medications) might represent identical adherence behavior Preventive care visits: Annual physicals routine dental cleanings represent preventive behavior whether ’s 3rd 10th visit Routine lab monitoring: Quarterly hemoglobin A1c tests stable diabetes may represent identical surveillance activity Routine imaging surveillance: Follow-mammograms CT scans stable conditions represent monitoring process","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/choosing-between-methods.html","id":"when-event-order-matters","dir":"Articles","previous_headings":"When Methods Differ and Why","what":"When Event Order Matters","title":"Choosing Between Methods","text":"Exchangeability unreasonable (naive) recurrent outcomes health research. outcomes, occurrence event may impact probability subsequent events (.e. events different clinical meaning biological mechanisms depending fall count sequence). Consider following examples: Cancer recurrences: First vs second recurrence may different biology prognosis Hospital readmissions: Early readmissions may indicate discharge planning issues, multiple readmissions suggest complex care needs Medication adverse events: Early vs late adverse events may different mechanisms clinical significance Seizures: Early vs late seizures may indicate different disease progression patterns (depending underlying cause)","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/choosing-between-methods.html","id":"documenting-your-choice","dir":"Articles","previous_headings":"","what":"Documenting Your Choice","title":"Choosing Between Methods","text":"position censoring pattern result equivalent results two estimators, can make decision MCC estimator use based computational efficiency pick Dong-Yasui estimator. rest us dealing scenarios estimators expected differ, choice estimators align outcome interest research question. Regardless group fall , recommend explicitly documenting estimator used (choice made).","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/choosing-between-methods.html","id":"special-case---delayed-study-entry","dir":"Articles","previous_headings":"","what":"Special Case - Delayed Study Entry","title":"Choosing Between Methods","text":"patients enter study different times (.e., left-truncated follow-time), SCI method supports tstart_var parameter. See mcc() documentation details.","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/choosing-between-methods.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Choosing Between Methods","text":"methods estimate parameter mathematically equivalent certain conditions Events exchangeable → Equation method Event order matters → SCI method Special requirements: Use SCI method need left truncation support","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/mccount.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to mccount","text":"studying diseases medical interventions, patients often experience events can occur multiple times (e.g., hospitalizations, infections, tumor recurrences). Traditional survival analysis methods typically focus time first event, potentially missing important information total disease burden. Many patients experience events can occur multiple times—like hospital readmissions, infections, tumor recurrences. Traditional survival analysis concerned first event account competing risks like death. Alternatively, Mean Cumulative Count (MCC) provides complete picture estimating expected number events per person given time, properly accounting : Multiple occurrences event (recurrent events) Events prevent future occurrences (competing risks like death) Incomplete follow-(censoring)","code":"library(mccount) library(dplyr) library(survival)"},{"path":"https://kennethataylor.github.io/mccount/articles/mccount.html","id":"clinical-example-bladder-cancer-recurrences","dir":"Articles","previous_headings":"","what":"Clinical Example: Bladder Cancer Recurrences","title":"Introduction to mccount","text":"’ll use bladder1 dataset survival package, contains data bladder cancer recurrences randomized trial comparing three treatments: placebo, pyridoxine, thiotepa. bladder1 dataset contains 118 patients followed tumor recurrences. key variables : id: Patient identifier stop: Time event censoring status: Event type (0 = censored, 1 = recurrence, 2 = death bladder disease, 3 = death cause) treatment: Treatment group (placebo, pyridoxine, thiotepa)","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/mccount.html","id":"data-preparation","dir":"Articles","previous_headings":"","what":"Data Preparation","title":"Introduction to mccount","text":"MCC analysis, need ensure competing event variable proper coding: 0 = censoring 1 = event interest (recurrence) 2 = competing event (death cause)","code":"# Prepare data for MCC analysis bladder_mcc <- bladder1 |>   # Combine death causes into a single competing event indicator   mutate(status = if_else(status >= 2, 2, status))"},{"path":"https://kennethataylor.github.io/mccount/articles/mccount.html","id":"basic-mcc-analysis","dir":"Articles","previous_headings":"","what":"Basic MCC Analysis","title":"Introduction to mccount","text":"Let’s calculate MCC bladder cancer recurrences entire cohort: Notice mcc() warn user participants whose data end explicitly censoring event (0) competing event (2) final row. function provides warning ensure user aware also aware implicitly interpreted package. function also lets user know MCC estimate incorrect mccount’s implicit assumption incorrect.","code":"# Calculate MCC using the Dong-Yasui equation method mcc_overall <- mcc(   data = bladder_mcc,   id_var = \"id\",   time_var = \"stop\",   cause_var = \"status\",   method = \"equation\" ) #> Warning: Found 13 participants where last observation is an event of interest #> (`cause_var` = 1) #> First 5 IDs: 13, 15, 16, 19, 24 #> Total affected: 13 participants #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates"},{"path":"https://kennethataylor.github.io/mccount/articles/mccount.html","id":"understanding-the-output","dir":"Articles","previous_headings":"Basic MCC Analysis","what":"Understanding the Output","title":"Introduction to mccount","text":"Just calling mcc object ’ve created print method used, preview MCC estimates time point, exact mcc() call used generate output: package also includes S3 method summary() function output useful details: can also extract MCC estimate end study follow-using mcc_final_values(mcc_overall) /extract MCC values specific time points (MCC end follow-). example:","code":"mcc_overall #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 6 × 2 #>    time    mcc #>   <int>  <dbl> #> 1     0 0      #> 2     1 0.0256 #> 3     2 0.112  #> 4     3 0.241  #> 5     4 0.276  #> 6     5 0.320 #> # ... with 45 more rows #> ── Call ── #>  #> mcc(data = bladder_mcc, id_var = \"id\", time_var = \"stop\", cause_var = \"status\",  #>     method = \"equation\") # Get summary statistics summary(mcc_overall) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Total participants: 118 #>  #> ── Summary Statistics ── #>  #> Observation period: \"[0, 64]\" #> Time to MCC = 1.0: 22 #> Time to maximum MCC: 53 #> MCC at end of follow-up: 2.2672 #>  #> ── Event Count Composition #> Events of interest: 189 #> Competing risk events: 29 #> Censoring events: 76 # Extract key timepoints key_times <- c(6, 12, 24, 36, 48, 60)  # months mcc_at_times <- mcc_overall$mcc_table |>   filter(time %in% key_times) |>   mutate(     years = time / 12,     mcc = round(mcc, 3)   ) |>   select(years, time, mcc)  mcc_at_times #> # A tibble: 6 × 3 #>   years  time   mcc #>   <dbl> <int> <dbl> #> 1   0.5     6 0.391 #> 2   1      12 0.622 #> 3   2      24 1.16  #> 4   3      36 1.64  #> 5   4      48 2.03  #> 6   5      60 2.27"},{"path":"https://kennethataylor.github.io/mccount/articles/mccount.html","id":"visualization","dir":"Articles","previous_headings":"Basic MCC Analysis","what":"Visualization","title":"Introduction to mccount","text":"mccount provides flexible plotting capabilities can combined ggplot2 functions/syntax:  step function shows expected number bladder cancer recurrences accumulates entire study follow-period.","code":"# Basic plot plot(mcc_overall) +   labs(     title = \"Bladder Cancer Recurrence Burden\",     subtitle = \"Mean cumulative count over time\",     x = \"Time (Months)\"   ) +   scale_x_continuous(     breaks = c(seq(       0, max(mcc_overall$mcc_table$time),        by = 12       )     )) +     geom_line_mcc(mcc_overall)"},{"path":"https://kennethataylor.github.io/mccount/articles/mccount.html","id":"mcc-interpretation","dir":"Articles","previous_headings":"","what":"MCC Interpretation","title":"Introduction to mccount","text":"estimated MCC can interpreted number events per person expect among individuals experienced competing risk event given time. Looking print summary(mcc_overall), MCC end follow-2.27 - average, bladder cancer survivor experiences 2.27 recurrences 64 months. population 100 similar patients, expect approximately 2.27 * 100 = 227 total recurrences 64 months. accounts fact patients die experience recurrences. Dong, et al.1 provide additional guidance interpreting MCC (emphasis added): Note MCC marginal measure (opposed conditional measure) disease burden, similar [cumulative incidence], interpretation conditional survival free competing risk events. Also, MCC assume independence event interest competing-risk event.","code":""},{"path":"https://kennethataylor.github.io/mccount/articles/mccount.html","id":"stratifying-by-treatment-groups","dir":"Articles","previous_headings":"","what":"Stratifying by Treatment Groups","title":"Introduction to mccount","text":"’s common may want estimate MCC stratified specific characteristic, like \"treatment\" group. mcc() provides simple argument assist :","code":"# Calculate MCC by treatment group mcc_by_treatment <- mcc(   data = bladder_mcc,   id_var = \"id\",   time_var = \"stop\",   cause_var = \"status\",   by = \"treatment\",   method = \"equation\" ) #> Warning: Found 7 participants where last observation is an event of interest #> (`cause_var` = 1) #> First 5 IDs: 13, 15, 16, 19, 24 #> Total affected: 7 participants #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> Warning: Found 4 participants where last observation is an event of interest #> (`cause_var` = 1) #> ! ID: 51, 64, 67, 70 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> Warning: Found 2 participants where last observation is an event of interest #> (`cause_var` = 1) #> ! ID: 83, 104 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates  # Summary by group summary(mcc_by_treatment) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Total participants: 118 #> ℹ Overall observation period: \"[0, 64]\" #>  #> ── Summary by Group (treatment) ── #>  #> ── Group: placebo #> Participants in group: 48 #> Group observation period: \"[0, 64]\" #> Time to MCC = 1.0: 17 #> Time to maximum MCC: 53 #> MCC at end of follow-up: 2.6137 #> Events of interest: 87 #> Competing risk events: 11 #> Censoring events: 30 #>  #> ── Group: pyridoxine #> Participants in group: 32 #> Group observation period: \"[0, 60]\" #> Time to MCC = 1.0: 19 #> Time to maximum MCC: 49 #> MCC at end of follow-up: 2.5831 #> Events of interest: 57 #> Competing risk events: 7 #> Censoring events: 21 #>  #> ── Group: thiotepa #> Participants in group: 38 #> Group observation period: \"[0, 59]\" #> Time to MCC = 1.0: 27 #> Time to maximum MCC: 47 #> MCC at end of follow-up: 1.5463 #> Events of interest: 45 #> Competing risk events: 11 #> Censoring events: 25"},{"path":"https://kennethataylor.github.io/mccount/articles/mccount.html","id":"visualizing-treatment-differences","dir":"Articles","previous_headings":"Stratifying by Treatment Groups","what":"Visualizing Treatment Differences","title":"Introduction to mccount","text":"functions mccount automatically recognize mcc_grouped S3 class adjust behavior accordingly. example, can feed mcc_by_treatment plot(), automatically knows plot MCC curve stratification variable.  Confidence intervals MCC can generated via bootstrapping.","code":"# Plot with treatment groups plot(mcc_by_treatment) +   labs(     title = \"Bladder Cancer Recurrence Burden by Treatment\",     subtitle = \"Mean cumulative count over time\",     x = \"Time (Months)\",     color = \"Treatment\"   ) +   scale_x_continuous(     breaks = seq(       0, max(mcc_by_treatment$original_data$time),        by = 12       )     ) +     geom_line_mcc(mcc_by_treatment)"},{"path":"https://kennethataylor.github.io/mccount/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kenneth . Taylor. Author, maintainer.","code":""},{"path":"https://kennethataylor.github.io/mccount/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Taylor K (2025). mccount: Estimate Recurrent Event Burden Competing Risks. R package version 0.0.0.9000, https://github.com/KennethATaylor/mccount.","code":"@Manual{,   title = {mccount: Estimate Recurrent Event Burden with Competing Risks},   author = {Kenneth A. Taylor},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://github.com/KennethATaylor/mccount}, }"},{"path":[]},{"path":"https://kennethataylor.github.io/mccount/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Estimate Recurrent Event Burden with Competing Risks","text":"mccount provides tools estimate mean cumulative count (MCC) recurrent events presence competing risks. Unlike traditional cumulative incidence methods consider first occurrence event, MCC accounts multiple occurrences event type per individual, providing informative measure total burden recurrent events population. Available MCC methods package include Dong-Yasui sum cumulative incidences estimators, based work Dong, et al.1 Users can also estimate MCC using weighted Dong-Yasui estimator.2","code":""},{"path":"https://kennethataylor.github.io/mccount/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate Recurrent Event Burden with Competing Risks","text":"can install development version mccount like :","code":"# install.packages(\"pak\") pak::pkg_install(\"KennethATaylor/mccount\")"},{"path":"https://kennethataylor.github.io/mccount/index.html","id":"why-mean-cumulative-count","dir":"","previous_headings":"","what":"Why Mean Cumulative Count?","title":"Estimate Recurrent Event Burden with Competing Risks","text":"context clinical epidemiological studies, subjects may experience multiple recurrent events given follow-period. Traditional methods like Kaplan-Meier cumulative incidence account first occurrence event ignore subsequent recurrent events, can lead underestimation true disease burden. MCC: Summarizes events occur population given time Accounts competing risks may terminate follow-Provides complete picture recurrent event burden interpretable expected number events per subject specific time point","code":""},{"path":"https://kennethataylor.github.io/mccount/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Estimate Recurrent Event Burden with Competing Risks","text":"use mccount research, please cite package addition relevant original methodology paper(s).","code":"citation(\"mccount\")"},{"path":"https://kennethataylor.github.io/mccount/reference/as.data.frame.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert mcc object to data.frame — as.data.frame.mcc","title":"Convert mcc object to data.frame — as.data.frame.mcc","text":"Extracts MCC estimates mcc object returns standard data.frame. useful analysis working packages expect standard data.frame objects.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/as.data.frame.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert mcc object to data.frame — as.data.frame.mcc","text":"","code":"# S3 method for class 'mcc' as.data.frame(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/reference/as.data.frame.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert mcc object to data.frame — as.data.frame.mcc","text":"x mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/as.data.frame.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert mcc object to data.frame — as.data.frame.mcc","text":"data.frame MCC estimates","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/as.data.frame.mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert mcc object to data.frame — as.data.frame.mcc","text":"","code":"# Create sample data library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2) ) |>   arrange(id, time)  # Calculate MCC mcc_result <- mcc(df, \"id\", \"time\", \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Convert to data.frame mcc_df <- as.data.frame(mcc_result) print(mcc_df) #>   time  mcc #> 1    0 0.00 #> 2    2 0.25 #> 3    3 0.50 #> 4    6 0.75 #> 5    7 1.00 class(mcc_df)  # \"data.frame\" #> [1] \"data.frame\"  # This is equivalent to extracting mcc_final identical(mcc_df, as.data.frame(mcc_result$mcc_final)) #> [1] TRUE  # Useful for further analysis with base R functions summary(mcc_df) #>       time          mcc       #>  Min.   :0.0   Min.   :0.00   #>  1st Qu.:2.0   1st Qu.:0.25   #>  Median :3.0   Median :0.50   #>  Mean   :3.6   Mean   :0.50   #>  3rd Qu.:6.0   3rd Qu.:0.75   #>  Max.   :7.0   Max.   :1.00   plot(mcc_df$time, mcc_df$mcc, type = \"s\")   # Clean up rm(df, mcc_result, mcc_df)"},{"path":"https://kennethataylor.github.io/mccount/reference/as_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert objects to mcc class — as_mcc","title":"Convert objects to mcc class — as_mcc","text":"Converts objects MCC class. useful calculation results sources want treat MCC objects.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/as_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert objects to mcc class — as_mcc","text":"","code":"as_mcc(x, method, weighted = FALSE, by_group = NULL, call = NULL, ...)"},{"path":"https://kennethataylor.github.io/mccount/reference/as_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert objects to mcc class — as_mcc","text":"x Object convert mcc method Method used calculation (\"equation\" \"sci\") weighted Logical indicating weighted estimation used by_group Optional name grouping variable call Optional function call store ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/as_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert objects to mcc class — as_mcc","text":"mcc S3 object","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/as_mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert objects to mcc class — as_mcc","text":"","code":"# Convert a data.frame to MCC object library(dplyr)  # Create a simple data.frame with MCC results mcc_data <- data.frame(   time = c(1, 2, 3, 4, 5),   mcc = c(0.1, 0.3, 0.5, 0.7, 1.0) )  # Convert to MCC object (equation method) mcc_obj <- as_mcc(mcc_data, method = \"equation\") print(mcc_obj) #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time   mcc #>   <dbl> <dbl> #> 1     1   0.1 #> 2     2   0.3 #> 3     3   0.5 #> 4     4   0.7 #> 5     5   1   is_mcc(mcc_obj)  # TRUE #> [1] TRUE  # Convert for SCI method (requires SumCIs column) sci_data <- data.frame(   time = c(1, 2, 3, 4, 5),   SumCIs = c(0.1, 0.3, 0.5, 0.7, 1.0) )  mcc_sci_obj <- as_mcc(sci_data, method = \"sci\") print(mcc_sci_obj) #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Sum of Cumulative Incidence Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time SumCIs #>   <dbl>  <dbl> #> 1     1    0.1 #> 2     2    0.3 #> 3     3    0.5 #> 4     4    0.7 #> 5     5    1    # Convert a list to MCC object mcc_list <- list(   mcc_final = data.frame(     time = c(1, 2, 3),     mcc = c(0.2, 0.5, 0.8)   ) )  mcc_from_list <- as_mcc(mcc_list, method = \"equation\") print(mcc_from_list) #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #>  #> ── MCC Estimates ── #>  #>   time mcc #> 1    1 0.2 #> 2    2 0.5 #> 3    3 0.8  # Clean up rm(mcc_data, sci_data, mcc_list, mcc_obj, mcc_sci_obj, mcc_from_list)"},{"path":"https://kennethataylor.github.io/mccount/reference/autoplot.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-plot method for mcc objects — autoplot.mcc","title":"Auto-plot method for mcc objects — autoplot.mcc","text":"Convenience function automatically creates appropriate plot mcc objects. called using base R plot() function.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/autoplot.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auto-plot method for mcc objects — autoplot.mcc","text":"","code":"# S3 method for class 'mcc' autoplot(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/reference/autoplot.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Auto-plot method for mcc objects — autoplot.mcc","text":"x mcc object ... Additional arguments passed plot.mcc","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/autoplot.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Auto-plot method for mcc objects — autoplot.mcc","text":"ggplot2 object","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/autoplot.mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auto-plot method for mcc objects — autoplot.mcc","text":"","code":"# Create sample data library(dplyr) library(ggplot2) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2),   treatment = c(\"Control\", \"Control\", \"Treatment\", \"Treatment\",                 \"Treatment\", \"Treatment\", \"Control\", \"Control\") ) |>   arrange(id, time)  # Calculate MCC mcc_result <- mcc(df, \"id\", \"time\", \"cause\", by = \"treatment\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates  # Use autoplot (ggplot2 style) p <- autoplot(mcc_result) print(p)   # Customize with ggplot2 functions p_custom <- autoplot(mcc_result) +   theme_classic() +   labs(caption = \"Data from hypothetical study\") +   geom_hline(yintercept = 1, linetype = \"dashed\", alpha = 0.5)  print(p_custom)   # Clean up rm(df, mcc_result, p, p_custom)"},{"path":"https://kennethataylor.github.io/mccount/reference/compare_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare mcc objects — compare_mcc","title":"Compare mcc objects — compare_mcc","text":"Compares two mcc objects returns summary differences. Useful comparing results different methods parameter settings.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/compare_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare mcc objects — compare_mcc","text":"","code":"compare_mcc(x, y, tolerance = 1e-06)"},{"path":"https://kennethataylor.github.io/mccount/reference/compare_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare mcc objects — compare_mcc","text":"x First mcc object y Second mcc object tolerance Numeric tolerance comparing MCC values (default: 1e-6)","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/compare_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare mcc objects — compare_mcc","text":"list summarizing comparison","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/compare_mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare mcc objects — compare_mcc","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2) ) |>   arrange(id, time)  # Calculate MCC using different methods mcc_eq <- mcc(df, \"id\", \"time\", \"cause\", method = \"equation\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject. mcc_sci <- mcc(df, \"id\", \"time\", \"cause\", method = \"sci\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Compare the results comparison <- compare_mcc(mcc_eq, mcc_sci) print(comparison) #>  #> ── MCC Object Comparison ─────────────────────────────────────────────────────── #> ! Objects differ in one or more aspects #>  #> ── Comparison Details ── #>  #> ✖ Methods match #> ✔ Weighted status matches #> ✔ Grouping status matches #> ✔ Grouping variables match #> ✔ Final values are close #> Maximum difference in final values: 0  # Clean up rm(df, mcc_eq, mcc_sci, comparison)"},{"path":"https://kennethataylor.github.io/mccount/reference/filter_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter mcc object by groups — filter_mcc","title":"Filter mcc object by groups — filter_mcc","text":"grouped mcc objects, extracts results specified groups . useful focusing specific groups interest creating custom visualizations.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/filter_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter mcc object by groups — filter_mcc","text":"","code":"filter_mcc(x, groups)"},{"path":"https://kennethataylor.github.io/mccount/reference/filter_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter mcc object by groups — filter_mcc","text":"x grouped mcc object groups Character vector group names include","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/filter_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter mcc object by groups — filter_mcc","text":"mcc object containing specified groups","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/filter_mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter mcc object by groups — filter_mcc","text":"","code":"# Create sample data with groups library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5, 6, 7, 8),   time = c(8, 1, 5, 2, 6, 7, 3, 3, 4, 9, 2),   cause = c(0, 0, 2, 1, 1, 1, 1, 2, 1, 0, 2),   treatment = c(\"Control\", \"Control\", \"Treatment\", \"Treatment\",                 \"Treatment\", \"Treatment\", \"Control\", \"Control\",                 \"Placebo\", \"Placebo\", \"Placebo\") ) |>   arrange(id, time)  # Grouped analysis mcc_full <- mcc(df, \"id\", \"time\", \"cause\", by = \"treatment\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 6 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates  # Show all groups mcc_groups(mcc_full) #> [1] \"Control\"   \"Treatment\" \"Placebo\"    # Filter to specific groups mcc_filtered <- filter_mcc(mcc_full, c(\"Control\", \"Treatment\")) mcc_groups(mcc_filtered)  # Only \"Control\" and \"Treatment\" #> [1] \"Control\"   \"Treatment\"  # Plot the filtered mcc object plot(mcc_filtered)   # Clean up rm(df, mcc_full, mcc_filtered)"},{"path":"https://kennethataylor.github.io/mccount/reference/geom_line_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"Adds horizontal vertical reference lines mark Mean Cumulative Count (MCC) reaches threshold. function returns list ggplot2 geoms can added existing plots using + operator. grouped analyses, creates separate reference lines group.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/geom_line_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"","code":"geom_line_mcc(   mcc_object,   threshold = 1,   linetype = 2,   color = NULL,   alpha = 0.7,   linewidth = 0.5,   show_labels = FALSE,   label_size = 3,   label_nudge_x = 0,   label_nudge_y = 0.05 )"},{"path":"https://kennethataylor.github.io/mccount/reference/geom_line_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"mcc_object object class mcc containing MCC estimates. threshold numeric;determines MCC value threshold use (default = 1.0) linetype Line type reference lines. Default 2 (dashed). Can numeric (1-6) character (\"solid\", \"dashed\", \"dotted\", etc.). color Color reference lines. NULL (default), uses gray. alpha Transparency level reference lines. Default 0.7. linewidth Width reference lines. Default 0.5. show_labels Logical indicating whether add text labels intersection points. Default FALSE. label_size Size text labels show_labels = TRUE. Default 3. label_nudge_x Horizontal offset labels. Default 0. label_nudge_y Vertical offset labels. Default 0.05.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/geom_line_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"ggplot2 layer object can added ggplot using + operator.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/geom_line_mcc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"function identifies time MCC first reaches exceeds specified MCC threshold. creates: horizontal line x = 0 time MCC = threshold vertical line y = 0 MCC = threshold time point grouped analyses, separate reference lines created group reaches MCC = threshold. Groups never reach MCC = threshold reference lines added. function designed work seamlessly existing plot.mcc() method can chained using ggplot2's + syntax.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/geom_line_mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"","code":"if (FALSE) { # \\dontrun{ # Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2),   group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\") ) |>   arrange(id, time)  # Ungrouped analysis mcc_overall <- mcc(df, \"id\", \"time\", \"cause\")  # Basic plot with reference lines plot(mcc_overall) +   geom_line_mcc(mcc_overall) +   labs(title = \"MCC with Reference Lines at 1.0\")  # Grouped analysis mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"group\")  # Plot with group-specific reference lines plot(mcc_grouped) +   geom_line_mcc(mcc_grouped, linetype = \"dotted\", alpha = 0.8) +   labs(title = \"Grouped MCC with Reference Lines\")  # With labels plot(mcc_overall) +   geom_line_mcc(mcc_overall, show_labels = TRUE, color = \"red\") +   labs(title = \"MCC with Labeled Reference Lines\")  # Clean up rm(df, mcc_overall, mcc_grouped) } # }"},{"path":"https://kennethataylor.github.io/mccount/reference/get_time_to_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","title":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","text":"Helper function identifies first time point Mean Cumulative Count (MCC) reaches exceeds threshold. MCC value threshold represents time population experiences average <threshold> event(s).","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/get_time_to_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","text":"","code":"get_time_to_mcc(mcc_data, mcc_column, threshold = 1)"},{"path":"https://kennethataylor.github.io/mccount/reference/get_time_to_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","text":"mcc_data data frame containing MCC estimates time. typically mcc_final component mcc object. mcc_column string specifying name column containing MCC values. method = \"equation\", typically \"mcc\". method = \"sci\", typically \"SumCIs\". threshold numeric;determines MCC value threshold use (default = 1.0)","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/get_time_to_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","text":"numeric value representing time MCC first reaches exceeds threshold, NA_real_ MCC never reaches threshold observed follow-period.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/get_time_to_mcc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","text":"MCC represents expected cumulative number events per person population initially risk. MCC = threshold, indicates population experienced average 1 event per person. milestone can useful : Identifying event burden reaches clinical epidemiological significance Comparing event timing across different exposure groups populations Setting thresholds intervention planning Note MCC values can exceed threshold, indicating threshold number events per person average, distinguishes probability-based measures like cumulative incidence bounded 0 1.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/is_grouped.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if mcc object is from grouped analysis — is_grouped","title":"Check if mcc object is from grouped analysis — is_grouped","text":"Check mcc object grouped analysis","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/is_grouped.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if mcc object is from grouped analysis — is_grouped","text":"","code":"is_grouped(x)"},{"path":"https://kennethataylor.github.io/mccount/reference/is_grouped.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if mcc object is from grouped analysis — is_grouped","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/is_grouped.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if mcc object is from grouped analysis — is_grouped","text":"Logical indicating whether analysis grouped","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/is_grouped.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if mcc object is from grouped analysis — is_grouped","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2),   group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\") ) |>   arrange(id, time)  # Ungrouped analysis mcc_ungrouped <- mcc(df, \"id\", \"time\", \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject. is_grouped(mcc_ungrouped)  # FALSE #> [1] FALSE  # Grouped analysis mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"group\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates is_grouped(mcc_grouped)  # TRUE #> [1] TRUE  # Clean up rm(df, mcc_ungrouped, mcc_grouped)"},{"path":"https://kennethataylor.github.io/mccount/reference/is_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if object is an mcc result — is_mcc","title":"Check if object is an mcc result — is_mcc","text":"Check object mcc result","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/is_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if object is an mcc result — is_mcc","text":"","code":"is_mcc(x)"},{"path":"https://kennethataylor.github.io/mccount/reference/is_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if object is an mcc result — is_mcc","text":"x object test","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/is_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if object is an mcc result — is_mcc","text":"TRUE x mcc object, FALSE otherwise","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/is_mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if object is an mcc result — is_mcc","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2) ) |>   arrange(id, time)  # Calculate MCC mcc_result <- mcc(df, \"id\", \"time\", \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Test if it's an MCC object is_mcc(mcc_result)  # TRUE #> [1] TRUE  # Clean up rm(df, mcc_result)"},{"path":"https://kennethataylor.github.io/mccount/reference/is_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if mcc object uses weighted estimation — is_weighted","title":"Check if mcc object uses weighted estimation — is_weighted","text":"Check mcc object uses weighted estimation","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/is_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if mcc object uses weighted estimation — is_weighted","text":"","code":"is_weighted(x)"},{"path":"https://kennethataylor.github.io/mccount/reference/is_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if mcc object uses weighted estimation — is_weighted","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/is_weighted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if mcc object uses weighted estimation — is_weighted","text":"Logical indicating whether weighted estimation used","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/is_weighted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if mcc object uses weighted estimation — is_weighted","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2) ) |>   arrange(id, time)  # Calculate unweighted MCC mcc_unweighted <- mcc(df, \"id\", \"time\", \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject. is_weighted(mcc_unweighted)  # FALSE #> [1] FALSE  # Create weighted data df_weighted <- df |>   group_by(id) |>   slice(1) |>   ungroup() |>   mutate(weights = runif(n(), 0.5, 2.0)) |>   select(id, weights) |>   right_join(df, by = \"id\") |>   arrange(id, time)  # Calculate weighted MCC mcc_weighted <- mcc(df_weighted, \"id\", \"time\", \"cause\", weights = \"weights\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject. is_weighted(mcc_weighted)  # TRUE #> [1] TRUE  # Clean up rm(df, df_weighted, mcc_unweighted, mcc_weighted)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Mean Cumulative Count (MCC) — mcc","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"Calculates Mean Cumulative Count (MCC), estimates expected cumulative number events per person time, accounting potential competing risks censoring. function provides unified interface two different estimation approaches: \"equation\" method sum cumulative incidence (\"sci\") method. \"equation\" method calculates MCC directly probability calculations, \"sci\" method derives MCC summing cumulative incidence functions recurrent event. two approaches yield equivalent results certain circumstances. , choice methods depe#' Calculate Mean Cumulative Count (MCC) Calculates Mean Cumulative Count (MCC), estimates expected cumulative number events per person time, accounting potential competing risks censoring. function provides unified interface two different estimation approaches: \"equation\" method sum cumulative incidence (\"sci\") method. \"equation\" method calculates MCC directly probability calculations, \"sci\" method derives MCC summing cumulative incidence functions recurrent event. two approaches yield equivalent results certain circumstances. , choice methods depends specific outcome, analysis needs, data structure.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"","code":"mcc(   data,   id_var,   time_var,   cause_var,   by = NULL,   method = c(\"equation\", \"sci\"),   tstart_var = NULL,   weights = NULL,   adjust_times = TRUE,   time_precision = 1e-06,   include_details = TRUE )"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"data (data.frame tbl_df) data.frame tibble containing required variables id_var (string) Name column containing participant identifiers time_var (string) Name column containing follow-times cause_var (string) Name column containing event indicator values (1 = event interest, 2 = competing risk, 0 = censoring) (string, optional) Name column group calculating MCC within subgroups. provided, MCC calculated separately level variable method (string) Method use MCC calculation. Either \"equation\" (default) \"sci\" (sum cumulative incidence) tstart_var (string) Name column containing start times follow-incorporating left truncation. allowed specified method = \"sci\". NULL (default), constant value 0 used calculation (.e., right truncation ) weights (string, optional) Name column containing weights weighted MCC estimation. Currently supported method = \"equation\". provided, weights must non-negative non-missing adjust_times (logical) TRUE (default), automatically adjusts times account outcome events competing risk events occurring time time_precision (numeric) Precision used adjusting simultaneous events (default: 1e-6). Must positive numeric value include_details (logical) Whether include detailed calculation tables intermediate objects output. Default TRUE, returns calculation details. Setting FALSE returns final MCC estimates, making function efficient bootstrapping","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"S3 object class \"mcc\" method-specific subclasses. object contains: include_details = TRUE (default): method = \"equation\": mcc_final: tibble columns time mcc mcc_table: tibble detailed calculation steps original_data: input data standardized column names adjusted_data: Present time adjustments applied method = \"sci\": mcc_final: tibble columns time MCC (expressed SumCIs) sci_table: tibble cumulative incidence event number sum all_cis: list cumulative incidence data event number mcc_base: tibble calculation details MCC original_data: input data standardized column names adjusted_data: Present time adjustments applied include_details = FALSE: mcc_final: tibble columns time mcc (SumCIs method = \"sci\") objects include metadata: method: method used calculation weighted: Logical indicating whether weighted estimation used by_group: Name grouping variable (grouped analyses) call: original function call specified, tibbles contain additional column grouping variable values, object additional class \"mcc_grouped\".","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"Dong H, Robison LL, Leisenring WM, Martin LJ, Armstrong GT, Yasui Y. Estimating burden recurrent events presence competing risks: method mean cumulative count. J Epidemiol. 2015 Apr 1;181(7):532-40. doi: 10.1093/aje/kwu289 Gaber CE, Edwards JK, Lund JL, Peery AF, Richardson DB, Kinlaw AC. Inverse Probability Weighting Estimate Exposure Effects Burden Recurrent Outcomes Presence Competing Events. J Epidemiol. 2023;192(5):830-839. doi: 10.1093/aje/kwad031","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"","code":"# Attach dplyr library(dplyr) # Create sample data with recurrent events df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3), # Times will be adjusted for id = 5   cause = c(0, 0, 2, 1, 1, 1, 1, 2)  ) |>   arrange(id, time)  # Sort the data by id and time  # Print the dataset print(\"Hypothetical dataset from Dong et al. (2015):\") #> [1] \"Hypothetical dataset from Dong et al. (2015):\" print(df) #>   id time cause #> 1  1    8     0 #> 2  2    1     0 #> 3  3    5     2 #> 4  4    2     1 #> 5  4    6     1 #> 6  4    7     1 #> 7  5    3     1 #> 8  5    3     2  # Calculate MCC using the equation method mcc_eq <- mcc(df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Print the S3 object mcc_eq #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time   mcc #>   <dbl> <dbl> #> 1     0  0    #> 2     2  0.25 #> 3     3  0.5  #> 4     6  0.75 #> 5     7  1    #> ── Call ── #>  #> mcc(data = df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\")  # Get summary summary(mcc_eq) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Total participants: 5 #>  #> ── Summary Statistics ── #>  #> Observation period: \"[0, 8]\" #> Time to MCC = 1.0: 7 #> Time to maximum MCC: 7 #> MCC at end of follow-up: 1 #>  #> ── Event Count Composition  #> Events of interest: 4 #> Competing risk events: 2 #> Censoring events: 2  # Extract MCC estimates mcc_estimates(mcc_eq) #> # A tibble: 5 × 2 #>    time   mcc #>   <dbl> <dbl> #> 1     0  0    #> 2     2  0.25 #> 3     3  0.5  #> 4     6  0.75 #> 5     7  1     # Extract calculation details mcc_details(mcc_eq) #> # A tibble: 9 × 8 #>    time nrisk censor event cmprk overall_surv_previous ave_events   mcc #>   <dbl> <dbl>  <dbl> <dbl> <dbl>                 <dbl>      <dbl> <dbl> #> 1  0        5      0     0     0                  1          0     0    #> 2  1        5      1     0     0                  1          0     0    #> 3  2        4      0     1     0                  1          0.25  0.25 #> 4  3        4      0     1     0                  1          0.25  0.5  #> 5  3.00     4      0     0     1                  1          0     0.5  #> 6  5        3      0     0     1                  0.75       0     0.5  #> 7  6        2      0     1     0                  0.5        0.25  0.75 #> 8  7        2      1     1     0                  0.5        0.25  1    #> 9  8        1      1     0     0                  0.5        0     1     # Calculate MCC using the sum of cumulative incidence method mcc_sci <- mcc(   df,   id_var = \"id\",   time_var = \"time\",   cause_var = \"cause\",   method = \"sci\" ) #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  mcc_sci #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Sum of Cumulative Incidence Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time SumCIs #>   <dbl>  <dbl> #> 1     0   0    #> 2     2   0.25 #> 3     3   0.5  #> 4     6   0.75 #> 5     7   1    #> ── Call ── #>  #> mcc(data = df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\",  #>     method = \"sci\")  # Clean up rm(df, mcc_eq, mcc_sci)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_details.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract calculation details from mcc objects — mcc_details","title":"Extract calculation details from mcc objects — mcc_details","text":"Extract calculation details mcc objects","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_details.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract calculation details from mcc objects — mcc_details","text":"","code":"mcc_details(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_details.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract calculation details from mcc objects — mcc_details","text":"x mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_details.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract calculation details from mcc objects — mcc_details","text":"tibble calculation details, NULL available","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_details.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract calculation details from mcc objects — mcc_details","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2) ) |>   arrange(id, time)  # Calculate MCC with details mcc_eq <- mcc(df, \"id\", \"time\", \"cause\", method = \"equation\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject. mcc_sci <- mcc(df, \"id\", \"time\", \"cause\", method = \"sci\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Extract calculation details details_eq <- mcc_details(mcc_eq)   # Returns mcc_table details_sci <- mcc_details(mcc_sci) # Returns sci_table  print(details_eq) #> # A tibble: 9 × 8 #>    time nrisk censor event cmprk overall_surv_previous ave_events   mcc #>   <dbl> <dbl>  <dbl> <dbl> <dbl>                 <dbl>      <dbl> <dbl> #> 1  0        5      0     0     0                  1          0     0    #> 2  1        5      1     0     0                  1          0     0    #> 3  2        4      0     1     0                  1          0.25  0.25 #> 4  3        4      0     1     0                  1          0.25  0.5  #> 5  3.00     4      0     0     1                  1          0     0.5  #> 6  5        3      0     0     1                  0.75       0     0.5  #> 7  6        2      0     1     0                  0.5        0.25  0.75 #> 8  7        2      1     1     0                  0.5        0.25  1    #> 9  8        1      1     0     0                  0.5        0     1    print(details_sci) #> # A tibble: 9 × 5 #>    time   CI1   CI2   CI3 SumCIs #>   <dbl> <dbl> <dbl> <dbl>  <dbl> #> 1  0     0     0     0      0    #> 2  1     0     0     0      0    #> 3  2     0.25  0     0      0.25 #> 4  3     0.5   0     0      0.5  #> 5  3.00  0.5   0     0      0.5  #> 6  5     0.5   0     0      0.5  #> 7  6     0.5   0.25  0      0.75 #> 8  7     0.5   0.25  0.25   1    #> 9  8     0.5   0.25  0.25   1     # Clean up rm(df, mcc_eq, mcc_sci, details_eq, details_sci)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_equation.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Mean Cumulative Count using the equation method — mcc_equation","title":"Calculate Mean Cumulative Count using the equation method — mcc_equation","text":"Calculate Mean Cumulative Count using equation method","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_equation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Mean Cumulative Count using the equation method — mcc_equation","text":"","code":"mcc_equation(   data,   id_var,   time_var,   cause_var,   weights = NULL,   adjust_times = TRUE,   time_precision = 1e-06,   include_details = TRUE )"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_equation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Mean Cumulative Count using the equation method — mcc_equation","text":"data data.frame tibble containing required variables id_var Name column containing participant IDs (string symbol) time_var Name column containing follow-times (string symbol) cause_var Name column containing event indicators (string symbol) (1=event interest, 2=competing risk, 0=censoring) weights Name column containing weights (string, optional) adjust_times Whether automatically adjust times simultaneous events (default: TRUE) time_precision Precision used adjusting simultaneous events (default: 1e-6) include_details Whether include detailed calculation tables intermediate objects output (default: TRUE).","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_equation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Mean Cumulative Count using the equation method — mcc_equation","text":"list containing MCC results. include_details = TRUE, returns complete calculation details. Otherwise, returns final MCC estimates.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_estimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract MCC estimates from mcc objects — mcc_estimates","title":"Extract MCC estimates from mcc objects — mcc_estimates","text":"Extract MCC estimates mcc objects","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_estimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract MCC estimates from mcc objects — mcc_estimates","text":"","code":"mcc_estimates(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_estimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract MCC estimates from mcc objects — mcc_estimates","text":"x mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_estimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract MCC estimates from mcc objects — mcc_estimates","text":"tibble MCC estimates","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_estimates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract MCC estimates from mcc objects — mcc_estimates","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2) ) |>   arrange(id, time)  # Calculate MCC mcc_result <- mcc(df, \"id\", \"time\", \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Extract MCC estimates estimates <- mcc_estimates(mcc_result) print(estimates) #> # A tibble: 5 × 2 #>    time   mcc #>   <dbl> <dbl> #> 1     0  0    #> 2     2  0.25 #> 3     3  0.5  #> 4     6  0.75 #> 5     7  1     # For grouped analysis df_grouped <- df |>   mutate(group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\"))  mcc_grouped <- mcc(df_grouped, \"id\", \"time\", \"cause\", by = \"group\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates estimates_grouped <- mcc_estimates(mcc_grouped) print(estimates_grouped) #>     group  time   mcc #>    <char> <num> <num> #> 1:      A     0   0.0 #> 2:      A     3   0.5 #> 3:      B     0   0.0 #> 4:      B     2   0.5 #> 5:      B     6   1.0 #> 6:      B     7   1.5  # Clean up rm(df, df_grouped, mcc_result, mcc_grouped, estimates, estimates_grouped)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_final_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Get final MCC value for each group — mcc_final_values","title":"Get final MCC value for each group — mcc_final_values","text":"Extracts final (maximum time) MCC value group grouped analysis, overall final MCC value ungrouped analyses.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_final_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get final MCC value for each group — mcc_final_values","text":"","code":"mcc_final_values(x)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_final_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get final MCC value for each group — mcc_final_values","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_final_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get final MCC value for each group — mcc_final_values","text":"named numeric vector final MCC values","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_final_values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get final MCC value for each group — mcc_final_values","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2),   group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\") ) |>   arrange(id, time)  # Ungrouped analysis mcc_ungrouped <- mcc(df, \"id\", \"time\", \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject. mcc_final_values(mcc_ungrouped) #> Overall  #>       1   # Grouped analysis mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"group\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates mcc_final_values(mcc_grouped) #>   A   B  #> 0.5 1.5   # Clean up rm(df, mcc_ungrouped, mcc_grouped)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_grouping_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Get grouping variable name from grouped mcc object — mcc_grouping_var","title":"Get grouping variable name from grouped mcc object — mcc_grouping_var","text":"Get grouping variable name grouped mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_grouping_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get grouping variable name from grouped mcc object — mcc_grouping_var","text":"","code":"mcc_grouping_var(x)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_grouping_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get grouping variable name from grouped mcc object — mcc_grouping_var","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_grouping_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get grouping variable name from grouped mcc object — mcc_grouping_var","text":"Character string grouping variable name, NULL grouped","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_grouping_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get grouping variable name from grouped mcc object — mcc_grouping_var","text":"","code":"# Create sample data with groups library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2),   treatment = c(\"Control\", \"Control\", \"Treatment\", \"Treatment\",                 \"Treatment\", \"Treatment\", \"Control\", \"Control\") ) |>   arrange(id, time)  # Grouped analysis mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"treatment\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates  # Get grouping variable name mcc_grouping_var(mcc_grouped)  # \"treatment\" #> [1] \"treatment\"  # Clean up rm(df, mcc_grouped)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract unique groups from grouped mcc object — mcc_groups","title":"Extract unique groups from grouped mcc object — mcc_groups","text":"Extract unique groups grouped mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract unique groups from grouped mcc object — mcc_groups","text":"","code":"mcc_groups(x)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract unique groups from grouped mcc object — mcc_groups","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_groups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract unique groups from grouped mcc object — mcc_groups","text":"Character vector unique group values, NULL grouped","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_groups.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract unique groups from grouped mcc object — mcc_groups","text":"","code":"# Create sample data with groups library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5, 6, 7, 8),   time = c(8, 1, 5, 2, 6, 7, 3, 3, 4, 9, 2),   cause = c(0, 0, 2, 1, 1, 1, 1, 2, 1, 0, 2),   treatment = c(\"Control\", \"Control\", \"Treatment\", \"Treatment\",                 \"Treatment\", \"Treatment\", \"Control\", \"Control\",                 \"Placebo\", \"Placebo\", \"Placebo\") ) |>   arrange(id, time)  # Grouped analysis mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"treatment\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 6 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates  # Get all unique groups mcc_groups(mcc_grouped)  # \"Control\", \"Placebo\", \"Treatment\" #> [1] \"Control\"   \"Treatment\" \"Placebo\"    # Clean up rm(df, mcc_grouped)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the method used for MCC calculation — mcc_method","title":"Get the method used for MCC calculation — mcc_method","text":"Get method used MCC calculation","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the method used for MCC calculation — mcc_method","text":"","code":"mcc_method(x)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the method used for MCC calculation — mcc_method","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the method used for MCC calculation — mcc_method","text":"Character string indicating method (\"equation\" \"sci\")","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the method used for MCC calculation — mcc_method","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2),   group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\") ) |>   arrange(id, time)  # Calculate MCC mcc_result <- mcc(df, \"id\", \"time\", \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Get the method used mcc_method(mcc_result) #> [1] \"equation\"  # Clean up rm(df, mcc_result)"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_sci.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Mean Cumulative Count using the Sum of Cumulative Incidence method — mcc_sci","title":"Calculate Mean Cumulative Count using the Sum of Cumulative Incidence method — mcc_sci","text":"Calculate Mean Cumulative Count using Sum Cumulative Incidence method","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_sci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Mean Cumulative Count using the Sum of Cumulative Incidence method — mcc_sci","text":"","code":"mcc_sci(   data,   id_var,   time_var,   cause_var,   tstart_var = NULL,   adjust_times = TRUE,   time_precision = 1e-06,   include_details = TRUE )"},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_sci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Mean Cumulative Count using the Sum of Cumulative Incidence method — mcc_sci","text":"data data.frame tibble containing required variables id_var Name column containing participant IDs (string symbol) time_var Name column containing follow-event times (string symbol) cause_var Name column containing event indicators (string symbol) (1=event interest, 2=competing risk, 0=censoring) tstart_var Name column containing start times follow-(string symbol, optional). NULL (default), constant value 0 used observations. adjust_times Whether automatically adjust times simultaneous events (default: TRUE) time_precision Precision used adjusting simultaneous events (default: 1e-6) include_details Whether include detailed calculation tables intermediate objects output (default: TRUE).","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mcc_sci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Mean Cumulative Count using the Sum of Cumulative Incidence method — mcc_sci","text":"list containing MCC results. include_details=TRUE, returns complete calculation details. Otherwise, returns final MCC estimates.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mccount-package.html","id":null,"dir":"Reference","previous_headings":"","what":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"Calculates mean cumulative count (MCC) estimate expected cumulative number recurrent events per person time presence competing risks censoring. Implements Dong-Yasui equation method sum cumulative incidence method described Dong et al. (2015) doi:10.1093/aje/kwu289 . Supports inverse probability weighting causal inference outlined Gaber et al. (2023) doi:10.1093/aje/kwad031 . Provides S3 classes methods printing, summarizing, plotting, extracting results. Handles grouped analyses integrates 'ggplot2' visualization.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mccount-package.html","id":"main-function","dir":"Reference","previous_headings":"","what":"Main Function","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"mcc() - estimates MCC","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mccount-package.html","id":"s-object-system","dir":"Reference","previous_headings":"","what":"S3 Object System","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"package uses S3 classes provide consistent, extensible interface: Base Class: mcc - MCC results inherit class Method-Specific Classes: mcc_equation - Results Dong-Yasui estimator mcc_sci - Results Sum Cumulative Incidence estimator Analysis-Type Classes: mcc_weighted - Results using weighting mcc_grouped - Results grouped/stratified analysis Classes combine hierarchically (e.g., c(\"mcc_grouped\", \"mcc_weighted\", \"mcc_equation\", \"mcc\")).","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mccount-package.html","id":"available-methods","dir":"Reference","previous_headings":"","what":"Available Methods","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"Generic S3 Methods: print.mcc() - Formatted display results summary.mcc() - Statistical summaries plot.mcc() - Visualization ggplot2 autoplot.mcc() - ggplot2-style plotting (ggplot2 loaded) .data.frame.mcc() - Convert standard data.frame as_mcc() - Convert objects MCC class Utility Functions: is_mcc() - Test object MCC result mcc_estimates() - Extract main results table mcc_details() - Extract calculation details mcc_method() - Get calculation method used is_weighted(), is_grouped() - Check analysis properties mcc_groups(), mcc_grouping_var() - Access grouping information filter_mcc() - Filter grouped results mcc_final_values() - Extract final MCC values compare_mcc() - Compare two MCC objects","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/mccount-package.html","id":"basic-usage","dir":"Reference","previous_headings":"","what":"Basic Usage","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"","code":"# Calculate MCC result <- mcc(data, \"id\", \"time\", \"cause\")  # Examine results result              # Uses print.mcc() summary(result)     # Uses summary.mcc() plot(result)        # Uses plot.mcc()  # Extract components estimates <- mcc_estimates(result) details <- mcc_details(result) final_values <- mcc_final_values(result)  # Grouped analysis grouped_result <- mcc(data, \"id\", \"time\", \"cause\", by = \"treatment\") plot(grouped_result) filter_mcc(grouped_result, \"Treatment A\")"},{"path":"https://kennethataylor.github.io/mccount/reference/mccount-package.html","id":"plotting","dir":"Reference","previous_headings":"","what":"Plotting","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"package provides flexible plotting S3 methods automatically adapt analysis type:","code":"# Basic plotting plot(mcc_result)                    # MCC over time plot(mcc_result, type = \"details\")  # Calculation components  # Customization plot(mcc_result, colors = c(\"red\", \"blue\"), title = \"Custom Title\")  # ggplot2 integration library(ggplot2) autoplot(mcc_result) + theme_classic()  # Further customization plot(mcc_result) +   geom_hline(yintercept = 1, linetype = \"dashed\") +   labs(caption = \"Dashed line at MCC = 1\")"},{"path":"https://kennethataylor.github.io/mccount/reference/mccount-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"Core Methods: Dong H, Robison LL, Leisenring WM, Martin LJ, Armstrong GT, Yasui Y. Estimating burden recurrent events presence competing risks: method mean cumulative count. J Epidemiol. 2015;181(7):532-40. Weighted Extension: Gaber CE, Edwards JK, Lund JL, Peery AF, Richardson DB, Kinlaw AC. Inverse Probability Weighting Estimate Exposure Effects Burden Recurrent Outcomes Presence Competing Events. J Epidemiol. 2023;192(5):830-839.","code":""},{"path":[]},{"path":"https://kennethataylor.github.io/mccount/reference/mccount-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"Maintainer: Kenneth . Taylor kenneth.taylor.dpt@gmail.com (ORCID)","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/plot.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot MCC results — plot.mcc","title":"Plot MCC results — plot.mcc","text":"Creates plots Mean Cumulative Count (MCC) results. plotting method automatically adapts based mcc object class whether analysis grouped.","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/plot.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot MCC results — plot.mcc","text":"","code":"# S3 method for class 'mcc' plot(   x,   type = c(\"mcc\", \"components\"),   groups = NULL,   conf_int = FALSE,   colors = NULL,   title = NULL,   subtitle = NULL,   ... )"},{"path":"https://kennethataylor.github.io/mccount/reference/plot.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot MCC results — plot.mcc","text":"x mcc object type Character string specifying plot type: \"mcc\" (default): Plot MCC estimates time \"components\": Show individual cumulative incidence components (SCI method ) groups Character vector specifying groups include grouped analyses. NULL (default), groups included conf_int Logical indicating whether include confidence intervals available colors Character vector colors use groups. NULL, uses default colors title Character string plot title. NULL, generates automatic title subtitle Character string plot subtitle. NULL, generates automatic subtitle ... Additional arguments passed ggplot2 functions","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/plot.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot MCC results — plot.mcc","text":"ggplot2 object","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/plot.mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot MCC results — plot.mcc","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2),   group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\") ) |>   arrange(id, time)  # Basic MCC plot (ungrouped) mcc_result <- mcc(df, \"id\", \"time\", \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject. plot(mcc_result)   # Grouped analysis with custom colors mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"group\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates plot(mcc_grouped)   # Customize the grouped plot plot(mcc_grouped,      colors = c(\"red\", \"blue\"),      title = \"MCC by Treatment Group\",      subtitle = \"Comparison of Event Burden\")   # Plot only specific groups plot(mcc_grouped, groups = c(\"A\"))   # Compare different methods - equation method only shows MCC mcc_eq <- mcc(df, \"id\", \"time\", \"cause\", method = \"equation\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject. plot(mcc_eq)   # SCI method can show components of cumulative incidence components mcc_sci <- mcc(df, \"id\", \"time\", \"cause\", method = \"sci\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject. plot(mcc_sci)  # Shows main MCC plot  plot(mcc_sci, type = \"components\")  # Shows CI components   # Clean up rm(df, mcc_result, mcc_grouped, mcc_eq, mcc_sci)"},{"path":"https://kennethataylor.github.io/mccount/reference/print.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for mcc objects — print.mcc","title":"Print method for mcc objects — print.mcc","text":"Print method mcc objects","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/print.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for mcc objects — print.mcc","text":"","code":"# S3 method for class 'mcc' print(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/reference/print.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for mcc objects — print.mcc","text":"x mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/print.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for mcc objects — print.mcc","text":"x invisibly","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/print.mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print method for mcc objects — print.mcc","text":"","code":"# Attach dplyr library(dplyr) # Create sample data with recurrent events df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3), # Times will be adjusted for id = 5   cause = c(0, 0, 2, 1, 1, 1, 1, 2)  ) |>   arrange(id, time)  # Sort the data by id and time  # Calculate MCC using the equation method (default) mcc_eq <- mcc(df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Print the S3 object (uses print.mcc method) mcc_eq #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time   mcc #>   <dbl> <dbl> #> 1     0  0    #> 2     2  0.25 #> 3     3  0.5  #> 4     6  0.75 #> 5     7  1    #> ── Call ── #>  #> mcc(data = df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\")  # Calculate MCC using the sum of cumulative incidence method mcc_sci <- mcc(   df,   id_var = \"id\",   time_var = \"time\",   cause_var = \"cause\",   method = \"sci\" ) #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Print the S3 object mcc_sci #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Sum of Cumulative Incidence Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time SumCIs #>   <dbl>  <dbl> #> 1     0   0    #> 2     2   0.25 #> 3     3   0.5  #> 4     6   0.75 #> 5     7   1    #> ── Call ── #>  #> mcc(data = df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\",  #>     method = \"sci\")  # Clean up rm(df, mcc_eq, mcc_sci)"},{"path":"https://kennethataylor.github.io/mccount/reference/print.mcc_comparison.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for MCC comparison objects — print.mcc_comparison","title":"Print method for MCC comparison objects — print.mcc_comparison","text":"Print method MCC comparison objects","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/print.mcc_comparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for MCC comparison objects — print.mcc_comparison","text":"","code":"# S3 method for class 'mcc_comparison' print(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/reference/print.mcc_comparison.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for MCC comparison objects — print.mcc_comparison","text":"x mcc_comparison object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/print.mcc_comparison.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for MCC comparison objects — print.mcc_comparison","text":"x invisibly","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/print.summary.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for mcc summary objects — print.summary.mcc","title":"Print method for mcc summary objects — print.summary.mcc","text":"Print method mcc summary objects","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/print.summary.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for mcc summary objects — print.summary.mcc","text":"","code":"# S3 method for class 'summary.mcc' print(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/reference/print.summary.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for mcc summary objects — print.summary.mcc","text":"x summary.mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/print.summary.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for mcc summary objects — print.summary.mcc","text":"x invisibly","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/summary.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for mcc objects — summary.mcc","title":"Summary method for mcc objects — summary.mcc","text":"Summary method mcc objects","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/summary.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for mcc objects — summary.mcc","text":"","code":"# S3 method for class 'mcc' summary(object, ...)"},{"path":"https://kennethataylor.github.io/mccount/reference/summary.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for mcc objects — summary.mcc","text":"object mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/summary.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for mcc objects — summary.mcc","text":"summary object class summary.mcc","code":""},{"path":"https://kennethataylor.github.io/mccount/reference/summary.mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary method for mcc objects — summary.mcc","text":"","code":"# Attach dplyr library(dplyr) # Create sample data with recurrent events df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3), # Times will be adjusted for id = 5   cause = c(0, 0, 2, 1, 1, 1, 1, 2)  ) |>   arrange(id, time)  # Sort the data by id and time  # Calculate MCC using the equation method (default) mcc_eq <- mcc(df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  summary(mcc_eq) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Total participants: 5 #>  #> ── Summary Statistics ── #>  #> Observation period: \"[0, 8]\" #> Time to MCC = 1.0: 7 #> Time to maximum MCC: 7 #> MCC at end of follow-up: 1 #>  #> ── Event Count Composition  #> Events of interest: 4 #> Competing risk events: 2 #> Censoring events: 2  # Calculate MCC using the sum of cumulative incidence method mcc_sci <- mcc(   df,   id_var = \"id\",   time_var = \"time\",   cause_var = \"cause\",   method = \"sci\" ) #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  summary(mcc_sci) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Sum of Cumulative Incidence Method #> ℹ Total participants: 5 #>  #> ── Summary Statistics ── #>  #> Observation period: \"[0, 8]\" #> Time to MCC = 1.0: 7 #> Time to maximum MCC: 7 #> MCC at end of follow-up: 1 #>  #> ── Event Count Composition  #> Events of interest: 4 #> Competing risk events: 2 #> Censoring events: 2  # Clean up rm(df, mcc_eq, mcc_sci)"},{"path":"https://kennethataylor.github.io/mccount/news/index.html","id":"mccount-development-version","dir":"Changelog","previous_headings":"","what":"mccount (development version)","title":"mccount (development version)","text":"Initial CRAN submission.","code":""}]
