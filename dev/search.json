[{"path":"https://kennethataylor.github.io/mccount/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 mccount authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/choosing-between-methods.html","id":"two-approaches-same-goal","dir":"Articles","previous_headings":"","what":"Two Approaches, Same Goal","title":"Choosing Between Methods","text":"mccount implements two methods calculating mean cumulative count (MCC): Equation method: Direct calculation using Dong-Yasui estimator SCI method: Sum cumulative incidences approach estimate parameter mathematically equivalent specific conditions. conditions two estimators differ, choice two estimators made based research question hand, specifically characteristics outcome.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/choosing-between-methods.html","id":"when-methods-are-equivalent","dir":"Articles","previous_headings":"","what":"When Methods Are Equivalent","title":"Choosing Between Methods","text":"MCC estimators yield identical results specific conditions:","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/choosing-between-methods.html","id":"administrative-censoring-only","dir":"Articles","previous_headings":"When Methods Are Equivalent","what":"Administrative Censoring Only","title":"Choosing Between Methods","text":"methods mathematically equivalent censoring except end study follow-(.e. administrative censoring ) - , observe participants either experience competing risk reach end study follow-.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/choosing-between-methods.html","id":"synchronized-event-interval-censoring","dir":"Articles","previous_headings":"When Methods Are Equivalent","what":"Synchronized Event-Interval Censoring","title":"Choosing Between Methods","text":"Even censoring end follow-, two methods yield identical results censoring follows specific pattern. Censoring must occur everyone remaining risk experienced pth event, anyone (p+1)th. censoring pattern observed non-administrative censoring observed time intervals event count sequence synchronized cohort level. like call pattern synchronized event-interval censoring. Take applied example given Dong, et al.1 - assume 5 participants enrolled hypothetical study: Subject 1: alive end follow-administratively censored time (t8) Subject 2: Lost follow-censored t1 Subject 3: Died (competing-risk event) t5 Subject 4: Experience event interest t2, t6, t7 alive end follow-(administratively censored t8) Subject 5: Experienced event interest t3 died (competing risk event) time point example, methods equivalent non-administrative censoring happens everyone’s first event (.e., synchronized event-interval censoring):","code":"df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2)  )  # Calculating MCC using both estimators mcc_eq <- mcc(   df,   id_var = \"id\",   time_var = \"time\",   cause_var = \"cause\",   method = \"equation\" ) #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  mcc_sci <- mcc(   df,   id_var = \"id\",   time_var = \"time\",   cause_var = \"cause\",   method = \"sci\" ) #> ℹ Adjusted time points for events occurring simultaneously for the same subject. # Dong-Yasui estimator mcc_details(mcc_eq) #> # A tibble: 9 × 8 #>    time nrisk censor event cmprk overall_surv_previous ave_events   mcc #>   <dbl> <dbl>  <dbl> <dbl> <dbl>                 <dbl>      <dbl> <dbl> #> 1  0        5      0     0     0                  1          0     0    #> 2  1        5      1     0     0                  1          0     0    #> 3  2        4      0     1     0                  1          0.25  0.25 #> 4  3        4      0     1     0                  1          0.25  0.5  #> 5  3.00     4      0     0     1                  1          0     0.5  #> 6  5        3      0     0     1                  0.75       0     0.5  #> 7  6        2      0     1     0                  0.5        0.25  0.75 #> 8  7        2      0     1     0                  0.5        0.25  1    #> 9  8        2      2     0     0                  0.5        0     1  # Sum of cumulative incidences estimator mcc_details(mcc_sci) #> # A tibble: 9 × 5 #>    time   CI1   CI2   CI3 SumCIs #>   <dbl> <dbl> <dbl> <dbl>  <dbl> #> 1  0     0     0     0      0    #> 2  1     0     0     0      0    #> 3  2     0.25  0     0      0.25 #> 4  3     0.5   0     0      0.5  #> 5  3.00  0.5   0     0      0.5  #> 6  5     0.5   0     0      0.5  #> 7  6     0.5   0.25  0      0.75 #> 8  7     0.5   0.25  0.25   1    #> 9  8     0.5   0.25  0.25   1"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/choosing-between-methods.html","id":"when-methods-differ-and-why","dir":"Articles","previous_headings":"","what":"When Methods Differ and Why","title":"Choosing Between Methods","text":"results two estimators differ, reflects handle fundamental question outcome: event order matter outcome? Dong-Yasui estimator treats events exchangeable - someone censored 2nd event, affects calculation future events regardless whether 1st, 2nd, 3rd people. SCI method takes event-specific approach - someone censored 2nd event, affects calculations 3rd+ events, 1st/2nd events others.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/choosing-between-methods.html","id":"when-events-are-exchangeable","dir":"Articles","previous_headings":"When Methods Differ and Why","what":"When Events Are Exchangeable","title":"Choosing Between Methods","text":"Recurrent events healthcare context might reasonably considered exchangeable ordering irrelevant clinically biologically events represent underlying process routine, maintenance-type activities clinical meaning unrelated order recurrent event count. Consider following examples: Routine medication refills: refill chronic medications (blood pressure pills, diabetes medications) might represent identical adherence behavior Preventive care visits: Annual physicals routine dental cleanings represent preventive behavior whether ’s 3rd 10th visit Routine lab monitoring: Quarterly hemoglobin A1c tests stable diabetes may represent identical surveillance activity Routine imaging surveillance: Follow-mammograms CT scans stable conditions represent monitoring process","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/choosing-between-methods.html","id":"when-event-order-matters","dir":"Articles","previous_headings":"When Methods Differ and Why","what":"When Event Order Matters","title":"Choosing Between Methods","text":"Exchangeability unreasonable (naive) recurrent outcomes health research. outcomes, occurrence event may impact probability subsequent events (.e. events different clinical meaning biological mechanisms depending fall count sequence). Consider following examples: Cancer recurrences: First vs second recurrence may different biology prognosis Hospital readmissions: Early readmissions may indicate discharge planning issues, multiple readmissions suggest complex care needs Medication adverse events: Early vs late adverse events may different mechanisms clinical significance Seizures: Early vs late seizures may indicate different disease progression patterns (depending underlying cause)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/choosing-between-methods.html","id":"documenting-your-choice","dir":"Articles","previous_headings":"","what":"Documenting Your Choice","title":"Choosing Between Methods","text":"position censoring pattern result equivalent results two estimators, can make decision MCC estimator use based computational efficiency pick Dong-Yasui estimator. rest us dealing scenarios estimators expected differ, choice estimators align outcome interest research question. Regardless group fall , recommend explicitly documenting estimator used (choice made).","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/choosing-between-methods.html","id":"special-case---delayed-study-entry","dir":"Articles","previous_headings":"","what":"Special Case - Delayed Study Entry","title":"Choosing Between Methods","text":"patients enter study different times (.e., left-truncated follow-time), SCI method supports tstart_var parameter. See mcc() documentation details.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/choosing-between-methods.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Choosing Between Methods","text":"methods estimate parameter mathematically equivalent certain conditions Events exchangeable → Equation method Event order matters → SCI method Special requirements: Use SCI method need left truncation support","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Estimating MCC After Matching or Weighting","text":"Treatment assignment randomized observational studies recurrent events, can lead confounding bias estimating causal effects. mean cumulative count (MCC) can estimated applying propensity score methods address confounding, following approach described Gaber, et al.1 vignette demonstrates : Use inverse probability treatment weighting (IPTW) MCC estimation Apply MCC estimation various propensity score matching methods Interpret weighted matched results appropriately","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"when-to-use-weights-with-mcc","dir":"Articles","previous_headings":"","what":"When to Use Weights with MCC","title":"Estimating MCC After Matching or Weighting","text":"standard (unweighted) Dong-Yasui estimator provides unbiased estimates MCC randomized trials confounding bias. However, observational studies, need account measured confounders affect treatment assignment recurrent outcome. Key principle: Use weights want estimate causal effect treatment recurrent event burden, just describe observed association.","code":""},{"path":[]},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"step-1-estimate-propensity-scores-and-create-weights","dir":"Articles","previous_headings":"Inverse Probability of Treatment Weighting (IPTW)","what":"Step 1: Estimate Propensity Scores and Create Weights","title":"Estimating MCC After Matching or Weighting","text":"’ll use survival::bladder1 dataset create binary treatment variable demonstration:","code":"library(mccount) library(dplyr) library(WeightIt) library(MatchIt) library(patchwork)  # Create example data with binary treatment bladder_nested <- survival::bladder1 |>   mutate(status = if_else(status > 2, 2, status)) |>    filter(treatment %in% c(\"placebo\", \"thiotepa\")) |>   tidyr::nest(.by = c(id, treatment, number, size)) |>    mutate(treatment_binary = if_else(treatment == \"thiotepa\", 1, 0)) # Estimate propensity scores and create IPTW weights using WeightIt weight_obj <- weightit(   treatment_binary ~ number + size,    data = bladder_nested, )  # Extract weights bladder_nested$iptw_weights <- weight_obj$weights  bladder_example <- bladder_nested |>    tidyr::unnest(data)"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"step-2-estimate-weighted-mcc","dir":"Articles","previous_headings":"Inverse Probability of Treatment Weighting (IPTW)","what":"Step 2: Estimate Weighted MCC","title":"Estimating MCC After Matching or Weighting","text":"","code":"# Estimate MCC with IPTW weights mcc_weighted <- mcc(   data = bladder_example,   id_var = \"id\",   time_var = \"stop\",   cause_var = \"status\",   by = \"treatment\",   weights = \"iptw_weights\",   method = \"equation\" ) #> Warning: Found 7 participants where last observation is an event of interest #> (`cause_var` = 1) #> First 5 IDs: 13, 15, 16, 19, 24 #> Total affected: 7 participants #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> Warning: Found 2 participants where last observation is an event of interest #> (`cause_var` = 1) #> ! ID: 83, 104 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates  # Display results summary(mcc_weighted) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Weighted estimation: Yes #> ℹ Total participants: 86 #> ℹ Overall observation period: [0, 64] #>  #> ── Summary by Group (treatment) ── #>  #> ── Group: placebo #> Participants in group: 48 #> Group observation period: [0, 64] #> Time to MCC = 1.0: 17 #> Time to maximum MCC: 53 #> MCC at end of follow-up: 2.6759 #> Events of interest: 87 #> Competing risk events: 11 #> Censoring events: 30 #>  #> ── Group: thiotepa #> Participants in group: 38 #> Group observation period: [0, 59] #> Time to MCC = 1.0: 29 #> Time to maximum MCC: 47 #> MCC at end of follow-up: 1.4006 #> Events of interest: 45 #> Competing risk events: 11 #> Censoring events: 25"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"step-3-compare-weighted-vs-unweighted-results","dir":"Articles","previous_headings":"Inverse Probability of Treatment Weighting (IPTW)","what":"Step 3: Compare Weighted vs Unweighted Results","title":"Estimating MCC After Matching or Weighting","text":"weighted estimates represent causal effect treatment recurrent event burden, adjusted measured confounding.","code":"# Estimate unweighted MCC for comparison mcc_unweighted <- mcc(   data = bladder_example,   id_var = \"id\",   time_var = \"stop\",   cause_var = \"status\",   by = \"treatment\",   method = \"equation\" ) #> Warning: Found 7 participants where last observation is an event of interest #> (`cause_var` = 1) #> First 5 IDs: 13, 15, 16, 19, 24 #> Total affected: 7 participants #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> Warning: Found 2 participants where last observation is an event of interest #> (`cause_var` = 1) #> ! ID: 83, 104 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates  # Extract final MCC values for comparison weighted_final <- mcc_final_values(mcc_weighted) unweighted_final <- mcc_final_values(mcc_unweighted)  # Create comparison table comparison_table <- data.frame(   Method = c(\"Unweighted\", \"IPTW Weighted\"),   Control_MCC = c(     cards::round5(unweighted_final[1], digits = 2),     cards::round5(weighted_final[1], digits = 2)   ),   Treated_MCC = c(     cards::round5(unweighted_final[2], digits = 2),     cards::round5(weighted_final[2], digits = 2)   ) )  knitr::kable(comparison_table)"},{"path":[]},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"important-note-on-matching-weights","dir":"Articles","previous_headings":"Propensity Score Matching","what":"Important Note on Matching Weights","title":"Estimating MCC After Matching or Weighting","text":"propensity score matching: Simple 1:1 nearest neighbor matching without replacement: additional weighting necessary using matched dataset (matching weights untrimmed treated control units equal 1) Examples matching methods weights necessary include, limited : optimal matching, full matching, subclassification, matching replacement, using 1:k ratio (k > 1)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"example-11-nearest-neighbor-matching-no-weights-needed","dir":"Articles","previous_headings":"Propensity Score Matching","what":"Example: 1:1 Nearest Neighbor Matching (No Weights Needed)","title":"Estimating MCC After Matching or Weighting","text":"run match_nn console, ’ll see 76 original 86 patients matched using nearest neighbor approach, can change estimand can estimate nearest neighbor matching average treatment effect among treated (ATT) average treatment among remaining matched sample (ATM). See MatchIt details regarding matching methods causal estimands.","code":"# Perform 1:1 nearest neighbor matching match_nn <- matchit(   treatment_binary ~ size + number,   data = bladder_nested ) # Extract matched data (no additional weights needed) matched_nn_data <- match.data(match_nn) |>    tidyr::unnest(data)  # Estimate MCC on matched data without additional weights mcc_nn_matched <- mcc(   data = matched_nn_data,   id_var = \"id\",   time_var = \"stop\",    cause_var = \"status\",   by = \"treatment_binary\",   method = \"equation\"   # No weights argument needed for simple 1:1 matching (all weights are 1) ) #> ℹ Converting numeric grouping variable \"by_var\" to <factor> #> ℹ Found 2 unique groups: 0 and 1 #> Warning: Found 5 participants where last observation is an event of interest #> (`cause_var` = 1) #> ! ID: 13, 16, 19, 34, 44 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> Warning: Found 2 participants where last observation is an event of interest #> (`cause_var` = 1) #> ! ID: 83, 104 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates  summary(mcc_nn_matched) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Total participants: 76 #> ℹ Overall observation period: [0, 64] #>  #> ── Summary by Group (treatment_binary) ── #>  #> ── Group: 0  #> Participants in group: 38 #> Group observation period: [0, 64] #> Time to MCC = 1.0: 22 #> Time to maximum MCC: 53 #> MCC at end of follow-up: 2.5943 #> Events of interest: 63 #> Competing risk events: 7 #> Censoring events: 26 #>  #>  #> ── Group: 1  #> Participants in group: 38 #> Group observation period: [0, 59] #> Time to MCC = 1.0: 27 #> Time to maximum MCC: 47 #> MCC at end of follow-up: 1.5463 #> Events of interest: 45 #> Competing risk events: 11 #> Censoring events: 25"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"example-full-matching-with-weights","dir":"Articles","previous_headings":"Propensity Score Matching","what":"Example: Full Matching with Weights","title":"Estimating MCC After Matching or Weighting","text":"","code":"# Perform full matching (creates matching weights) match_obj <- matchit(   treatment_binary ~ size + number,   data = bladder_nested,   method = \"full\",      # Full matching creates weights   estimand = \"ATE\" )  # Check matching balance summary(match_obj) #>  #> Call: #> matchit(formula = treatment_binary ~ size + number, data = bladder_nested,  #>     method = \"full\", estimand = \"ATE\") #>  #> Summary of Balance for All Data: #>          Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance        0.4495        0.4358          0.2312     1.6411    0.0477 #> size            1.9211        2.0625         -0.0986     0.7794    0.0230 #> number          2.3158        1.9167          0.2232     2.0164    0.0587 #>          eCDF Max #> distance   0.1217 #> size       0.0636 #> number     0.1217 #>  #> Summary of Balance for Matched Data: #>          Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean #> distance        0.4422        0.4414          0.0141     1.0362    0.0094 #> size            1.9884        1.9767          0.0081     0.8714    0.0150 #> number          2.1008        2.0698          0.0173     1.1531    0.0177 #>          eCDF Max Std. Pair Dist. #> distance   0.0465           0.046 #> size       0.0310           0.268 #> number     0.0465           0.086 #>  #> Sample Sizes: #>               Control Treated #> All             48.     38.   #> Matched (ESS)   44.04   31.83 #> Matched         48.     38.   #> Unmatched        0.      0.   #> Discarded        0.      0.  # Extract matched data with weights matched_data <- match_data(match_obj) |>    tidyr::unnest(data)  # The 'weights' column contains the matching weights head(matched_data[c(\"id\", \"treatment\", \"weights\")]) #> # A tibble: 6 × 3 #>      id treatment weights #>   <int> <fct>       <dbl> #> 1     1 placebo      1.67 #> 2     2 placebo      1.12 #> 3     3 placebo      1.12 #> 4     4 placebo      1.12 #> 5     5 placebo      2.23 #> 6     6 placebo      1.12 # Estimate MCC using matching weights mcc_matched <- mcc(   data = matched_data,   id_var = \"id\",   time_var = \"stop\",   cause_var = \"status\",   by = \"treatment\",   weights = \"weights\",  # Use matching weights from MatchIt   method = \"equation\" ) #> Warning: Found 7 participants where last observation is an event of interest #> (`cause_var` = 1) #> First 5 IDs: 13, 15, 16, 19, 24 #> Total affected: 7 participants #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> Warning: Found 2 participants where last observation is an event of interest #> (`cause_var` = 1) #> ! ID: 83, 104 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates  summary(mcc_matched) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Weighted estimation: Yes #> ℹ Total participants: 86 #> ℹ Overall observation period: [0, 64] #>  #> ── Summary by Group (treatment) ── #>  #> ── Group: placebo #> Participants in group: 48 #> Group observation period: [0, 64] #> Time to MCC = 1.0: 17 #> Time to maximum MCC: 53 #> MCC at end of follow-up: 2.5748 #> Events of interest: 87 #> Competing risk events: 11 #> Censoring events: 30 #>  #> ── Group: thiotepa #> Participants in group: 38 #> Group observation period: [0, 59] #> Time to MCC = 1.0: 27 #> Time to maximum MCC: 47 #> MCC at end of follow-up: 1.6084 #> Events of interest: 45 #> Competing risk events: 11 #> Censoring events: 25"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"visualization-of-weightedmatched-results","dir":"Articles","previous_headings":"","what":"Visualization of Weighted/Matched Results","title":"Estimating MCC After Matching or Weighting","text":"","code":"p_unwt <- plot(mcc_unweighted) +   geom_line_mcc(mcc_unweighted) +   labs(subtitle = element_blank(), color = \"Treatment\") +   scale_y_continuous(limits = c(0, 2.75)) +   ggtitle(\"Unweighted\")  p_wt <- plot(mcc_weighted) +   geom_line_mcc(mcc_weighted) +   ggtitle(\"IPTW\") +   labs(subtitle = \"Estimand: ATE\", color = \"Treatment\") +   scale_y_continuous(limits = c(0, 2.75)) +   theme(axis.title.y = element_blank())  p_mwt <- plot(mcc_matched) +   geom_line_mcc(mcc_matched) +   ggtitle(\"Full Matching\") +   labs(subtitle = \"Estimand: ATE\", color = \"Treatment\") +   scale_y_continuous(limits = c(0, 2.75)) +   theme(axis.title.y = element_blank())  combined <- p_unwt | p_wt | p_mwt  combined +    plot_layout(guides = \"collect\") &   theme(legend.position = \"bottom\") #> Warning: `label` cannot be a <ggplot2::element_blank> object."},{"path":[]},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"causal-vs-descriptive-interpretation","dir":"Articles","previous_headings":"Key Interpretation Points","what":"Causal vs Descriptive Interpretation","title":"Estimating MCC After Matching or Weighting","text":"Unweighted MCC: Describes observed recurrent event burden treatment group Weighted/Matched MCC: Estimates causal effect treatment recurrent event burden, adjusting (measured) confounding","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"assumptions","dir":"Articles","previous_headings":"Key Interpretation Points","what":"Assumptions","title":"Estimating MCC After Matching or Weighting","text":"Weighted MCC estimation assumes standard causal inference assumptions: Consistency: potential outcome treatment =aA = observed outcome actually received treatment aa Positivity: individuals non-zero probability receiving treatment level (0<P(=|L)<10 < P(= |L) < 1) Conditional Exchangeability (unmeasured confounding): Given adjustment measured covariates L, treatment groups sufficiently exchangeable start follow-- risk outcome one group can reasonably assumed group time treatment assignment controlling confounding bias Correct model specification: propensity score model correctly (least sufficiently) captures relationship covariates treatment assignment","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"stabilized-vs-unstabilized-weights","dir":"Articles","previous_headings":"Key Interpretation Points","what":"Stabilized vs Unstabilized Weights","title":"Estimating MCC After Matching or Weighting","text":"Gaber, et al. paper2 uses stabilized weights, form: Wi=P(=)/P(=|Li) W_i = P(= ) / P(= | L_i) Stabilized weights typically better finite sample properties unstabilized weights (1/P(=|Li)1 / P(= | L_i)) tend less extreme stable (hence name).","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"not-covered","dir":"Articles","previous_headings":"","what":"Not Covered","title":"Estimating MCC After Matching or Weighting","text":"vignette covers use weights IPTW matching get adjusted MCC point estimate. get associated confidence intervals, need perform bootstrapping (isn’t covered vignette).","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/estimating-mcc-after-matching-or-weighting.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Estimating MCC After Matching or Weighting","text":"Simple 1:1 nearest neighbor matching without replacement require use matching weights analysis (weights 1 [matched] 0 [unmatched]) Complex matching methods, like full matching, optimal matching, matching replacement, 1:k ratio (k > 1), require using matching weights Always compare weighted/matched results unweighted results assess impact confounding adjustment Interpret weighted estimates causal effects standard causal inference assumptions","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/mccount.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to mccount","text":"studying diseases medical interventions, patients often experience events can occur multiple times (e.g., hospitalizations, infections, tumor recurrences). Traditional survival analysis methods typically focus time first event, potentially missing important information total disease burden. Many patients experience events can occur multiple times—like hospital readmissions, infections, tumor recurrences. Traditional survival analysis concerned first event account competing risks like death. Alternatively, mean cumulative count (MCC) provides complete picture estimating expected number events per person given time, properly accounting : Multiple occurrences event (recurrent events) Events prevent future occurrences (competing risks like death) Incomplete follow-(censoring)","code":"library(mccount) library(dplyr) library(survival)"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/mccount.html","id":"clinical-example-bladder-cancer-recurrences","dir":"Articles","previous_headings":"","what":"Clinical Example: Bladder Cancer Recurrences","title":"Introduction to mccount","text":"’ll use survival::bladder1 dataset survival package, contains data bladder cancer recurrences randomized trial comparing three treatments: placebo, pyridoxine, thiotepa. bladder1 dataset contains 118 patients followed tumor recurrences. key variables : id: Patient identifier stop: Time event censoring status: Event type (0 = censored, 1 = recurrence, 2 = death bladder disease, 3 = death cause) treatment: Treatment group (placebo, pyridoxine, thiotepa)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/mccount.html","id":"data-preparation","dir":"Articles","previous_headings":"","what":"Data Preparation","title":"Introduction to mccount","text":"MCC analysis, need ensure competing event variable proper coding: 0 = censoring 1 = event interest (recurrence) 2 = competing event (death cause)","code":"# Prepare data for MCC analysis bladder_mcc <- bladder1 |>   # Combine death causes into a single competing event indicator   mutate(status = if_else(status >= 2, 2, status))"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/mccount.html","id":"basic-mcc-analysis","dir":"Articles","previous_headings":"","what":"Basic MCC Analysis","title":"Introduction to mccount","text":"Let’s calculate MCC bladder cancer recurrences entire cohort: Notice mcc() warn user participants whose data end explicitly censoring event (0) competing event (2) final row. function provides warning ensure user aware also aware implicitly interpreted package. function also lets user know MCC estimate incorrect mccount’s implicit assumption incorrect.","code":"# Calculate MCC using the Dong-Yasui equation method mcc_overall <- mcc(   data = bladder_mcc,   id_var = \"id\",   time_var = \"stop\",   cause_var = \"status\" ) #> Warning: Found 13 participants where last observation is an event of interest #> (`cause_var` = 1) #> First 5 IDs: 13, 15, 16, 19, 24 #> Total affected: 13 participants #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/mccount.html","id":"available-estimators","dir":"Articles","previous_headings":"Basic MCC Analysis","what":"Available Estimators","title":"Introduction to mccount","text":"mcc() function can used calculate MCC using either Dong-Yasui estimator (method = \"equation\", default) sum cumulative incidence estimator (method = \"sci\"). See vignette(\"choosing--methods\") ?mcc details.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/mccount.html","id":"understanding-the-output","dir":"Articles","previous_headings":"Basic MCC Analysis","what":"Understanding the Output","title":"Introduction to mccount","text":"Just calling mcc object ’ve created print method used, preview MCC estimates time point, exact mcc() call used generate output: package also includes S3 method summary() function output useful details: can also extract MCC estimate end study follow-using mcc_final_values(mcc_overall) /extract MCC values specific time points (MCC end follow-). example:","code":"mcc_overall #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 6 × 2 #>    time    mcc #>   <int>  <dbl> #> 1     0 0      #> 2     1 0.0256 #> 3     2 0.112  #> 4     3 0.241  #> 5     4 0.276  #> 6     5 0.320 #> # ... with 45 more rows #> ── Call ── #>  #> mcc(data = bladder_mcc, id_var = \"id\", time_var = \"stop\", cause_var = \"status\") # Get summary statistics summary(mcc_overall) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Total participants: 118 #>  #> ── Summary Statistics ── #>  #> Observation period: [0, 64] #> Time to MCC = 1.0: 22 #> Time to maximum MCC: 53 #> MCC at end of follow-up: 2.2672 #>  #> ── Event Count Composition #> Events of interest: 189 #> Competing risk events: 29 #> Censoring events: 76 # Extract key timepoints key_times <- c(6, 12, 24, 36, 48, 60)  # months mcc_at_times <- mcc_overall$mcc_table |>   filter(time %in% key_times) |>   mutate(     years = time / 12,     mcc = cards::round5(mcc, 3)   ) |>   select(years, time, mcc)  mcc_at_times #> # A tibble: 6 × 3 #>   years  time   mcc #>   <dbl> <int> <dbl> #> 1   0.5     6 0.391 #> 2   1      12 0.622 #> 3   2      24 1.16  #> 4   3      36 1.64  #> 5   4      48 2.03  #> 6   5      60 2.27"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/mccount.html","id":"visualization","dir":"Articles","previous_headings":"Basic MCC Analysis","what":"Visualization","title":"Introduction to mccount","text":"mccount provides flexible plotting capabilities can combined ggplot2 functions/syntax:  step function shows expected number bladder cancer recurrences accumulates entire study follow-period.","code":"# Basic plot plot(mcc_overall) +   labs(     title = \"Bladder Cancer Recurrence Burden\",     subtitle = \"Mean cumulative count over time\",     x = \"Time (Months)\"   ) +   scale_x_continuous(     breaks = c(seq(       0, max(mcc_overall$mcc_table$time),        by = 12       )     )) +     geom_line_mcc(mcc_overall)"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/mccount.html","id":"mcc-interpretation","dir":"Articles","previous_headings":"","what":"MCC Interpretation","title":"Introduction to mccount","text":"estimated MCC can interpreted number events per person expect among individuals experienced competing risk event given time. Looking print summary(mcc_overall), MCC end follow-2.27 - average, bladder cancer survivor experiences 2.27 recurrences 64 months. population 100 similar patients, expect approximately 2.27 * 100 = 227 total recurrences 64 months. accounts fact patients die experience recurrences. Dong, et al.1 provide additional guidance interpreting MCC (emphasis added): Note MCC marginal measure (opposed conditional measure) disease burden, similar [cumulative incidence], interpretation conditional survival free competing risk events. Also, MCC assume independence event interest competing-risk event.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/articles/mccount.html","id":"stratifying-by-treatment-groups","dir":"Articles","previous_headings":"","what":"Stratifying by Treatment Groups","title":"Introduction to mccount","text":"’s common may want estimate MCC stratified specific characteristic, like \"treatment\" group. mcc() provides simple argument assist :","code":"# Calculate MCC by treatment group mcc_by_treatment <- mcc(   data = bladder_mcc,   id_var = \"id\",   time_var = \"stop\",   cause_var = \"status\",   by = \"treatment\",   method = \"equation\" ) #> Warning: Found 7 participants where last observation is an event of interest #> (`cause_var` = 1) #> First 5 IDs: 13, 15, 16, 19, 24 #> Total affected: 7 participants #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> Warning: Found 4 participants where last observation is an event of interest #> (`cause_var` = 1) #> ! ID: 51, 64, 67, 70 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> Warning: Found 2 participants where last observation is an event of interest #> (`cause_var` = 1) #> ! ID: 83, 104 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates  # Summary by group summary(mcc_by_treatment) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Total participants: 118 #> ℹ Overall observation period: [0, 64] #>  #> ── Summary by Group (treatment) ── #>  #> ── Group: placebo #> Participants in group: 48 #> Group observation period: [0, 64] #> Time to MCC = 1.0: 17 #> Time to maximum MCC: 53 #> MCC at end of follow-up: 2.6137 #> Events of interest: 87 #> Competing risk events: 11 #> Censoring events: 30 #>  #> ── Group: pyridoxine #> Participants in group: 32 #> Group observation period: [0, 60] #> Time to MCC = 1.0: 19 #> Time to maximum MCC: 49 #> MCC at end of follow-up: 2.5831 #> Events of interest: 57 #> Competing risk events: 7 #> Censoring events: 21 #>  #> ── Group: thiotepa #> Participants in group: 38 #> Group observation period: [0, 59] #> Time to MCC = 1.0: 27 #> Time to maximum MCC: 47 #> MCC at end of follow-up: 1.5463 #> Events of interest: 45 #> Competing risk events: 11 #> Censoring events: 25"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/mccount.html","id":"visualizing-treatment-differences","dir":"Articles","previous_headings":"Stratifying by Treatment Groups","what":"Visualizing Treatment Differences","title":"Introduction to mccount","text":"functions mccount automatically recognize mcc_grouped S3 class adjust behavior accordingly. example, can feed mcc_by_treatment plot(), automatically knows plot MCC curve stratification variable.  Confidence intervals MCC can generated via bootstrapping.","code":"# Plot with treatment groups plot(mcc_by_treatment) +   labs(     title = \"Bladder Cancer Recurrence Burden by Treatment\",     subtitle = \"Mean cumulative count over time\",     x = \"Time (Months)\",     color = \"Treatment\"   ) +   scale_x_continuous(     breaks = seq(       0, max(mcc_by_treatment$original_data$time),        by = 12       )     ) +     geom_line_mcc(mcc_by_treatment)"},{"path":"https://kennethataylor.github.io/mccount/dev/articles/mccount.html","id":"weighted-mcc-analysis","dir":"Articles","previous_headings":"","what":"Weighted MCC Analysis","title":"Introduction to mccount","text":"mccount also allows estimation weighted MCC setting observational studies want account measured confounding /types bias via matching weighting. See vignette(\"estimating-mcc--matching--weighting\") details.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kenneth . Taylor. Author, maintainer, copyright holder.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Taylor K (2025). mccount: Estimate Recurrent Event Burden Competing Risks. R package version 0.1.1.9000, https://github.com/KennethATaylor/mccount.","code":"@Manual{,   title = {mccount: Estimate Recurrent Event Burden with Competing Risks},   author = {Kenneth A. Taylor},   year = {2025},   note = {R package version 0.1.1.9000},   url = {https://github.com/KennethATaylor/mccount}, }"},{"path":[]},{"path":"https://kennethataylor.github.io/mccount/dev/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Estimate Recurrent Event Burden with Competing Risks","text":"mccount provides tools estimate mean cumulative count (MCC) recurrent events presence competing risks. Unlike traditional cumulative incidence methods consider first occurrence event, MCC accounts multiple occurrences event type per individual, providing informative measure total burden recurrent events population. Available MCC methods package include Dong-Yasui sum cumulative incidences estimators, based work Dong, et al.1 Users can also estimate MCC using weighted Dong-Yasui estimator.2","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate Recurrent Event Burden with Competing Risks","text":"can install mccount CRAN using following code:","code":"install.packages(\"mccount\")"},{"path":"https://kennethataylor.github.io/mccount/dev/index.html","id":"development-version","dir":"","previous_headings":"Installation","what":"Development version","title":"Estimate Recurrent Event Burden with Competing Risks","text":"can install development version mccount like :","code":"# install.packages(\"pak\") pak::pkg_install(\"KennethATaylor/mccount\")"},{"path":"https://kennethataylor.github.io/mccount/dev/index.html","id":"why-mean-cumulative-count","dir":"","previous_headings":"","what":"Why Mean Cumulative Count?","title":"Estimate Recurrent Event Burden with Competing Risks","text":"context clinical epidemiological studies, subjects may experience multiple recurrent events given follow-period. Traditional methods like Kaplan-Meier cumulative incidence account first occurrence event ignore subsequent recurrent events, can lead underestimation true disease burden. MCC: Summarizes events occur population given time Accounts competing risks may terminate follow-Provides complete picture recurrent event burden interpretable expected number events per subject specific time point","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Estimate Recurrent Event Burden with Competing Risks","text":"use mccount research, please cite package addition relevant original methodology paper(s).","code":"citation(\"mccount\")"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/as.data.frame.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert mcc object to data.frame — as.data.frame.mcc","title":"Convert mcc object to data.frame — as.data.frame.mcc","text":"Extracts MCC estimates mcc object returns standard data.frame. useful analysis working packages expect standard data.frame objects.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/as.data.frame.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert mcc object to data.frame — as.data.frame.mcc","text":"","code":"# S3 method for class 'mcc' as.data.frame(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/as.data.frame.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert mcc object to data.frame — as.data.frame.mcc","text":"x mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/as.data.frame.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert mcc object to data.frame — as.data.frame.mcc","text":"data.frame MCC estimates","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/as.data.frame.mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert mcc object to data.frame — as.data.frame.mcc","text":"","code":"# Create sample data library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2) ) |>   arrange(id, time)  # Calculate MCC mcc_result <- mcc(df, \"id\", \"time\", \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Convert to data.frame mcc_df <- as.data.frame(mcc_result) print(mcc_df) #>   time  mcc #> 1    0 0.00 #> 2    2 0.25 #> 3    3 0.50 #> 4    6 0.75 #> 5    7 1.00 class(mcc_df)  # \"data.frame\" #> [1] \"data.frame\"  # This is equivalent to extracting mcc_final identical(mcc_df, as.data.frame(mcc_result$mcc_final)) #> [1] TRUE  # Useful for further analysis with base R functions summary(mcc_df) #>       time          mcc       #>  Min.   :0.0   Min.   :0.00   #>  1st Qu.:2.0   1st Qu.:0.25   #>  Median :3.0   Median :0.50   #>  Mean   :3.6   Mean   :0.50   #>  3rd Qu.:6.0   3rd Qu.:0.75   #>  Max.   :7.0   Max.   :1.00   plot(mcc_df$time, mcc_df$mcc, type = \"s\")   # Clean up rm(df, mcc_result, mcc_df)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/as_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert objects to mcc class — as_mcc","title":"Convert objects to mcc class — as_mcc","text":"Converts objects MCC class. useful calculation results sources want treat MCC objects.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/as_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert objects to mcc class — as_mcc","text":"","code":"as_mcc(x, method, weighted = FALSE, by_group = NULL, call = NULL, ...)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/as_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert objects to mcc class — as_mcc","text":"x Object convert mcc method Method used calculation (\"equation\" \"sci\") weighted Logical indicating weighted estimation used by_group Optional name grouping variable call Optional function call store ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/as_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert objects to mcc class — as_mcc","text":"mcc S3 object","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/as_mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert objects to mcc class — as_mcc","text":"","code":"# Convert a data.frame to MCC object library(dplyr)  # Create a simple data.frame with MCC results mcc_data <- data.frame(   time = c(1, 2, 3, 4, 5),   mcc = c(0.1, 0.3, 0.5, 0.7, 1.0) )  # Convert to MCC object (equation method) mcc_obj <- as_mcc(mcc_data, method = \"equation\") print(mcc_obj) #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time   mcc #>   <dbl> <dbl> #> 1     1   0.1 #> 2     2   0.3 #> 3     3   0.5 #> 4     4   0.7 #> 5     5   1   is_mcc(mcc_obj)  # TRUE #> [1] TRUE  # Convert for SCI method (requires SumCIs column) sci_data <- data.frame(   time = c(1, 2, 3, 4, 5),   SumCIs = c(0.1, 0.3, 0.5, 0.7, 1.0) )  mcc_sci_obj <- as_mcc(sci_data, method = \"sci\") print(mcc_sci_obj) #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Sum of Cumulative Incidence Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time SumCIs #>   <dbl>  <dbl> #> 1     1    0.1 #> 2     2    0.3 #> 3     3    0.5 #> 4     4    0.7 #> 5     5    1    # Convert a list to MCC object mcc_list <- list(   mcc_final = data.frame(     time = c(1, 2, 3),     mcc = c(0.2, 0.5, 0.8)   ) )  mcc_from_list <- as_mcc(mcc_list, method = \"equation\") print(mcc_from_list) #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #>  #> ── MCC Estimates ── #>  #>   time mcc #> 1    1 0.2 #> 2    2 0.5 #> 3    3 0.8  # Clean up rm(mcc_data, sci_data, mcc_list, mcc_obj, mcc_sci_obj, mcc_from_list)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/autoplot.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Auto-plot method for mcc objects — autoplot.mcc","title":"Auto-plot method for mcc objects — autoplot.mcc","text":"Convenience function automatically creates appropriate plot mcc objects. called using base R plot() function.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/autoplot.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auto-plot method for mcc objects — autoplot.mcc","text":"","code":"# S3 method for class 'mcc' autoplot(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/autoplot.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Auto-plot method for mcc objects — autoplot.mcc","text":"x mcc object ... Additional arguments passed plot.mcc","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/autoplot.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Auto-plot method for mcc objects — autoplot.mcc","text":"ggplot2 object","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/autoplot.mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auto-plot method for mcc objects — autoplot.mcc","text":"","code":"# Create sample data library(dplyr) library(ggplot2) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2),   treatment = c(\"Control\", \"Control\", \"Treatment\", \"Treatment\",                 \"Treatment\", \"Treatment\", \"Treatment\", \"Control\", \"Control\") ) |>   arrange(id, time)  # Calculate MCC mcc_result <- mcc(df, \"id\", \"time\", \"cause\", by = \"treatment\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Use autoplot (ggplot2 style) p <- autoplot(mcc_result) print(p)   # Customize with ggplot2 functions p_custom <- autoplot(mcc_result) +   theme_classic() +   labs(caption = \"Data from hypothetical study\") +   geom_hline(yintercept = 1, linetype = \"dashed\", alpha = 0.5)  print(p_custom)   # Clean up rm(df, mcc_result, p, p_custom)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/compare_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare mcc objects — compare_mcc","title":"Compare mcc objects — compare_mcc","text":"Compares two mcc objects returns summary differences. Useful comparing results different methods parameter settings.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/compare_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare mcc objects — compare_mcc","text":"","code":"compare_mcc(x, y, tolerance = 1e-06)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/compare_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare mcc objects — compare_mcc","text":"x First mcc object y Second mcc object tolerance Numeric tolerance comparing MCC values (default: 1e-6)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/compare_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare mcc objects — compare_mcc","text":"list summarizing comparison","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/compare_mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare mcc objects — compare_mcc","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2) ) |>   arrange(id, time)  # Calculate MCC using different methods mcc_eq <- mcc(df, \"id\", \"time\", \"cause\", method = \"equation\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. mcc_sci <- mcc(df, \"id\", \"time\", \"cause\", method = \"sci\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Compare the results comparison <- compare_mcc(mcc_eq, mcc_sci) print(comparison) #>  #> ── MCC Object Comparison ─────────────────────────────────────────────────────── #> ! Objects differ in one or more aspects #>  #> ── Comparison Details ── #>  #> ✖ Methods match #> ✔ Weighted status matches #> ✔ Grouping status matches #> ✔ Grouping variables match #> ✔ Final values are close #> Maximum difference in final values: 0  # Clean up rm(df, mcc_eq, mcc_sci, comparison)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/filter_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter mcc object by groups — filter_mcc","title":"Filter mcc object by groups — filter_mcc","text":"grouped mcc objects, extracts results specified groups . useful focusing specific groups interest creating custom visualizations.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/filter_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter mcc object by groups — filter_mcc","text":"","code":"filter_mcc(x, groups)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/filter_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter mcc object by groups — filter_mcc","text":"x grouped mcc object groups Character vector group names include","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/filter_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter mcc object by groups — filter_mcc","text":"mcc object containing specified groups","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/filter_mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter mcc object by groups — filter_mcc","text":"","code":"# Create sample data with groups library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5, 6, 6, 7, 8),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3, 4, 5, 9, 2),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2, 1, 0, 0, 2),   treatment = c(\"Control\", \"Control\", \"Treatment\", \"Treatment\",                 \"Treatment\", \"Treatment\", \"Treatment\", \"Control\", \"Control\",                 \"Placebo\", \"Placebo\", \"Placebo\", \"Placebo\") ) |>   arrange(id, time)  # Grouped analysis mcc_full <- mcc(df, \"id\", \"time\", \"cause\", by = \"treatment\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Show all groups mcc_groups(mcc_full) #> [1] \"Control\"   \"Treatment\" \"Placebo\"    # Filter to specific groups mcc_filtered <- filter_mcc(mcc_full, c(\"Control\", \"Treatment\")) mcc_groups(mcc_filtered)  # Only \"Control\" and \"Treatment\" #> [1] \"Control\"   \"Treatment\"  # Plot the filtered mcc object plot(mcc_filtered)   # Clean up rm(df, mcc_full, mcc_filtered)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/geom_line_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"Adds horizontal vertical reference lines mark Mean Cumulative Count (MCC) reaches threshold. function returns list ggplot2 geoms can added existing plots using + operator. grouped analyses, creates separate reference lines group.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/geom_line_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"","code":"geom_line_mcc(   mcc_object,   threshold = 1,   linetype = 2,   color = NULL,   alpha = 0.7,   linewidth = 0.5,   show_labels = FALSE,   label_size = 3,   label_nudge_x = 0,   label_nudge_y = 0.05 )"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/geom_line_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"mcc_object object class mcc containing MCC estimates. threshold numeric;determines MCC value threshold use (default = 1.0) linetype Line type reference lines. Default 2 (dashed). Can numeric (1-6) character (\"solid\", \"dashed\", \"dotted\", etc.). color Color reference lines. NULL (default), uses gray. alpha Transparency level reference lines. Default 0.7. linewidth Width reference lines. Default 0.5. show_labels Logical indicating whether add text labels intersection points. Default FALSE. label_size Size text labels show_labels = TRUE. Default 3. label_nudge_x Horizontal offset labels. Default 0. label_nudge_y Vertical offset labels. Default 0.05.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/geom_line_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"ggplot2 layer object can added ggplot using + operator.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/geom_line_mcc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"function identifies time MCC first reaches exceeds specified MCC threshold. creates: horizontal line x = 0 time MCC = threshold vertical line y = 0 MCC = threshold time point grouped analyses, separate reference lines created group reaches MCC = threshold. Groups never reach MCC = threshold reference lines added. function designed work seamlessly existing plot.mcc() method can chained using ggplot2's + syntax.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/geom_line_mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Reference Lines at an MCC Threshold to ggplot2 Objects — geom_line_mcc","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2),   group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\") ) |>   arrange(id, time)  # Ungrouped analysis mcc_overall <- mcc(df, \"id\", \"time\", \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Basic plot with reference lines plot(mcc_overall) +   geom_line_mcc(mcc_overall) +   labs(title = \"MCC with Reference Lines at 1.0\")   # Grouped analysis mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"group\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Plot with group-specific reference lines plot(mcc_grouped) +   geom_line_mcc(mcc_grouped, linetype = \"dotted\", alpha = 0.8) +   labs(title = \"Grouped MCC with Reference Lines\")   # With labels plot(mcc_overall) +   geom_line_mcc(mcc_overall, show_labels = TRUE, color = \"red\") +   labs(title = \"MCC with Labeled Reference Lines\")   # Clean up rm(df, mcc_overall, mcc_grouped)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/get_time_to_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","title":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","text":"Helper function identifies first time point Mean Cumulative Count (MCC) reaches exceeds threshold. MCC value threshold represents time population experiences average <threshold> event(s).","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/get_time_to_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","text":"","code":"get_time_to_mcc(mcc_data, mcc_column, threshold = 1)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/get_time_to_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","text":"mcc_data data frame containing MCC estimates time. typically mcc_final component mcc object. mcc_column string specifying name column containing MCC values. method = \"equation\", typically \"mcc\". method = \"sci\", typically \"SumCIs\". threshold numeric;determines MCC value threshold use (default = 1.0)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/get_time_to_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","text":"numeric value representing time MCC first reaches exceeds threshold, NA_real_ MCC never reaches threshold observed follow-period.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/get_time_to_mcc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get Time When MCC Reaches a Specific Threshold — get_time_to_mcc","text":"MCC represents expected cumulative number events per person population initially risk. MCC = threshold, indicates population experienced average 1 event per person. milestone can useful : Identifying event burden reaches clinical epidemiological significance Comparing event timing across different exposure groups populations Setting thresholds intervention planning Note MCC values can exceed threshold, indicating threshold number events per person average, distinguishes probability-based measures like cumulative incidence bounded 0 1.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_grouped.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if mcc object is from grouped analysis — is_grouped","title":"Check if mcc object is from grouped analysis — is_grouped","text":"Check mcc object grouped analysis","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_grouped.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if mcc object is from grouped analysis — is_grouped","text":"","code":"is_grouped(x)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_grouped.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if mcc object is from grouped analysis — is_grouped","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_grouped.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if mcc object is from grouped analysis — is_grouped","text":"Logical indicating whether analysis grouped","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_grouped.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if mcc object is from grouped analysis — is_grouped","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2),   group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\") ) |>   arrange(id, time)  # Ungrouped analysis mcc_ungrouped <- mcc(df, \"id\", \"time\", \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. is_grouped(mcc_ungrouped)  # FALSE #> [1] FALSE  # Grouped analysis mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"group\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. is_grouped(mcc_grouped)  # TRUE #> [1] TRUE  # Clean up rm(df, mcc_ungrouped, mcc_grouped)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if object is an mcc result — is_mcc","title":"Check if object is an mcc result — is_mcc","text":"Check object mcc result","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if object is an mcc result — is_mcc","text":"","code":"is_mcc(x)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if object is an mcc result — is_mcc","text":"x object test","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if object is an mcc result — is_mcc","text":"TRUE x mcc object, FALSE otherwise","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if object is an mcc result — is_mcc","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2)  ) |>   arrange(id, time)  # Calculate MCC mcc_result <- mcc(df, \"id\", \"time\", \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Test if it's an MCC object is_mcc(mcc_result)  # TRUE #> [1] TRUE  # Clean up rm(df, mcc_result)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if mcc object uses weighted estimation — is_weighted","title":"Check if mcc object uses weighted estimation — is_weighted","text":"Check mcc object uses weighted estimation","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if mcc object uses weighted estimation — is_weighted","text":"","code":"is_weighted(x)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if mcc object uses weighted estimation — is_weighted","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_weighted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if mcc object uses weighted estimation — is_weighted","text":"Logical indicating whether weighted estimation used","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/is_weighted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if mcc object uses weighted estimation — is_weighted","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2) ) |>   arrange(id, time)  # Calculate unweighted MCC mcc_unweighted <- mcc(df, \"id\", \"time\", \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. is_weighted(mcc_unweighted)  # FALSE #> [1] FALSE  # Create weighted data df_weighted <- df |>   group_by(id) |>   slice(1) |>   ungroup() |>   mutate(weights = runif(n(), 0.5, 2.0)) |>   select(id, weights) |>   right_join(df, by = \"id\") |>   arrange(id, time)  # Calculate weighted MCC mcc_weighted <- mcc(df_weighted, \"id\", \"time\", \"cause\", weights = \"weights\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. is_weighted(mcc_weighted)  # TRUE #> [1] TRUE  # Clean up rm(df, df_weighted, mcc_unweighted, mcc_weighted)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Mean Cumulative Count (MCC) — mcc","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"Calculates mean cumulative count (MCC), estimates expected cumulative number events per person time, accounting potential competing risks censoring. function provides unified interface two different estimation approaches: Dong-Yasui (\"equation\") method sum cumulative incidence (\"sci\") method. \"equation\" method calculates MCC directly probability calculations, \"sci\" method derives MCC summing cumulative incidence functions recurrent event. two approaches yield equivalent results certain circumstances. , choice methods depends specific outcome, analysis needs, data structure. See vignette(\"choosing--methods\") details.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"","code":"mcc(   data,   id_var,   time_var,   cause_var,   by = NULL,   method = c(\"equation\", \"sci\"),   tstart_var = NULL,   weights = NULL,   adjust_times = TRUE,   time_precision = 1e-06,   include_details = TRUE )"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"data (data.frame tbl_df) data.frame tibble containing required variables id_var (string) Name column containing participant identifiers time_var (string) Name column containing follow-times cause_var (string) Name column containing event indicator values (1 = event interest, 2 = competing risk, 0 = censoring) (string, optional) Name column group calculating MCC within subgroups. provided, MCC calculated separately level variable method (string) Method use MCC calculation. Either \"equation\" (default) \"sci\" (sum cumulative incidence) tstart_var (string) Name column containing start times follow-incorporating left truncation. allowed specified method = \"sci\". NULL (default), constant value 0 used calculation (.e., right truncation ) weights (string, optional) Name column containing weights weighted MCC estimation. Currently supported method = \"equation\". provided, weights must non-negative non-missing adjust_times (logical) TRUE (default), automatically adjusts times account outcome events competing risk events occurring time time_precision (numeric) Precision used adjusting simultaneous events (default: 1e-6). Must positive numeric value include_details (logical) Whether include detailed calculation tables intermediate objects output. Default TRUE, returns calculation details. Setting FALSE returns final MCC estimates, making function efficient bootstrapping","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"S3 object class \"mcc\" method-specific subclasses. object contains: include_details = TRUE (default): method = \"equation\": mcc_final: tibble columns time mcc mcc_table: tibble detailed calculation steps original_data: input data standardized column names adjusted_data: Present time adjustments applied method = \"sci\": mcc_final: tibble columns time MCC (expressed SumCIs) sci_table: tibble cumulative incidence event number sum all_cis: list cumulative incidence data event number mcc_base: tibble calculation details MCC original_data: input data standardized column names adjusted_data: Present time adjustments applied include_details = FALSE: mcc_final: tibble columns time mcc (SumCIs method = \"sci\") objects include metadata: method: method used calculation weighted: Logical indicating whether weighted estimation used by_group: Name grouping variable (grouped analyses) call: original function call specified, tibbles contain additional column grouping variable values, object additional class \"mcc_grouped\".","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"Dong H, Robison LL, Leisenring WM, Martin LJ, Armstrong GT, Yasui Y. Estimating burden recurrent events presence competing risks: method mean cumulative count. J Epidemiol. 2015 Apr 1;181(7):532-40. doi: 10.1093/aje/kwu289 Gaber CE, Edwards JK, Lund JL, Peery AF, Richardson DB, Kinlaw AC. Inverse Probability Weighting Estimate Exposure Effects Burden Recurrent Outcomes Presence Competing Events. J Epidemiol. 2023;192(5):830-839. doi: 10.1093/aje/kwad031","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Mean Cumulative Count (MCC) — mcc","text":"","code":"# Attach dplyr library(dplyr) # Create sample data with recurrent events df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3), # Times will be adjusted for id = 5   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2)  ) |>   arrange(id, time)  # Sort the data by id and time  # Print the dataset print(\"Hypothetical dataset from Dong et al. (2015):\") #> [1] \"Hypothetical dataset from Dong et al. (2015):\" print(df) #>   id time cause #> 1  1    8     0 #> 2  2    1     0 #> 3  3    5     2 #> 4  4    2     1 #> 5  4    6     1 #> 6  4    7     1 #> 7  4    8     0 #> 8  5    3     1 #> 9  5    3     2  # Calculate MCC using the equation method mcc_eq <- mcc(df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Print the S3 object mcc_eq #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time   mcc #>   <dbl> <dbl> #> 1     0  0    #> 2     2  0.25 #> 3     3  0.5  #> 4     6  0.75 #> 5     7  1    #> ── Call ── #>  #> mcc(data = df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\")  # Get summary summary(mcc_eq) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Total participants: 5 #>  #> ── Summary Statistics ── #>  #> Observation period: [0, 8] #> Time to MCC = 1.0: 7 #> Time to maximum MCC: 7 #> MCC at end of follow-up: 1 #>  #> ── Event Count Composition  #> Events of interest: 4 #> Competing risk events: 2 #> Censoring events: 3  # Extract MCC estimates mcc_estimates(mcc_eq) #> # A tibble: 5 × 2 #>    time   mcc #>   <dbl> <dbl> #> 1     0  0    #> 2     2  0.25 #> 3     3  0.5  #> 4     6  0.75 #> 5     7  1     # Extract calculation details mcc_details(mcc_eq) #> # A tibble: 9 × 8 #>    time nrisk censor event cmprk overall_surv_previous ave_events   mcc #>   <dbl> <dbl>  <dbl> <dbl> <dbl>                 <dbl>      <dbl> <dbl> #> 1  0        5      0     0     0                  1          0     0    #> 2  1        5      1     0     0                  1          0     0    #> 3  2        4      0     1     0                  1          0.25  0.25 #> 4  3        4      0     1     0                  1          0.25  0.5  #> 5  3.00     4      0     0     1                  1          0     0.5  #> 6  5        3      0     0     1                  0.75       0     0.5  #> 7  6        2      0     1     0                  0.5        0.25  0.75 #> 8  7        2      0     1     0                  0.5        0.25  1    #> 9  8        2      2     0     0                  0.5        0     1     # Calculate MCC using the sum of cumulative incidence method mcc_sci <- mcc(   df,   id_var = \"id\",   time_var = \"time\",   cause_var = \"cause\",   method = \"sci\" ) #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  mcc_sci #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Sum of Cumulative Incidence Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time SumCIs #>   <dbl>  <dbl> #> 1     0   0    #> 2     2   0.25 #> 3     3   0.5  #> 4     6   0.75 #> 5     7   1    #> ── Call ── #>  #> mcc(data = df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\",  #>     method = \"sci\")  # Clean up rm(df, mcc_eq, mcc_sci)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_details.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract calculation details from mcc objects — mcc_details","title":"Extract calculation details from mcc objects — mcc_details","text":"Extract calculation details mcc objects","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_details.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract calculation details from mcc objects — mcc_details","text":"","code":"mcc_details(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_details.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract calculation details from mcc objects — mcc_details","text":"x mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_details.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract calculation details from mcc objects — mcc_details","text":"tibble calculation details, NULL available","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_details.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract calculation details from mcc objects — mcc_details","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2)  ) |>   arrange(id, time)  # Calculate MCC with details mcc_eq <- mcc(df, \"id\", \"time\", \"cause\", method = \"equation\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. mcc_sci <- mcc(df, \"id\", \"time\", \"cause\", method = \"sci\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Extract calculation details details_eq <- mcc_details(mcc_eq)   # Returns mcc_table details_sci <- mcc_details(mcc_sci) # Returns sci_table  print(details_eq) #> # A tibble: 9 × 8 #>    time nrisk censor event cmprk overall_surv_previous ave_events   mcc #>   <dbl> <dbl>  <dbl> <dbl> <dbl>                 <dbl>      <dbl> <dbl> #> 1  0        5      0     0     0                  1          0     0    #> 2  1        5      1     0     0                  1          0     0    #> 3  2        4      0     1     0                  1          0.25  0.25 #> 4  3        4      0     1     0                  1          0.25  0.5  #> 5  3.00     4      0     0     1                  1          0     0.5  #> 6  5        3      0     0     1                  0.75       0     0.5  #> 7  6        2      0     1     0                  0.5        0.25  0.75 #> 8  7        2      0     1     0                  0.5        0.25  1    #> 9  8        2      2     0     0                  0.5        0     1    print(details_sci) #> # A tibble: 9 × 5 #>    time   CI1   CI2   CI3 SumCIs #>   <dbl> <dbl> <dbl> <dbl>  <dbl> #> 1  0     0     0     0      0    #> 2  1     0     0     0      0    #> 3  2     0.25  0     0      0.25 #> 4  3     0.5   0     0      0.5  #> 5  3.00  0.5   0     0      0.5  #> 6  5     0.5   0     0      0.5  #> 7  6     0.5   0.25  0      0.75 #> 8  7     0.5   0.25  0.25   1    #> 9  8     0.5   0.25  0.25   1     # Clean up rm(df, mcc_eq, mcc_sci, details_eq, details_sci)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_equation.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Mean Cumulative Count using the equation method — mcc_equation","title":"Calculate Mean Cumulative Count using the equation method — mcc_equation","text":"Calculate Mean Cumulative Count using equation method","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_equation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Mean Cumulative Count using the equation method — mcc_equation","text":"","code":"mcc_equation(   data,   id_var,   time_var,   cause_var,   weights = NULL,   adjust_times = TRUE,   time_precision = 1e-06,   include_details = TRUE )"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_equation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Mean Cumulative Count using the equation method — mcc_equation","text":"data data.frame tibble containing required variables id_var Name column containing participant IDs (string symbol) time_var Name column containing follow-times (string symbol) cause_var Name column containing event indicators (string symbol) (1=event interest, 2=competing risk, 0=censoring) weights Name column containing weights (string, optional) adjust_times Whether automatically adjust times simultaneous events (default: TRUE) time_precision Precision used adjusting simultaneous events (default: 1e-6) include_details Whether include detailed calculation tables intermediate objects output (default: TRUE).","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_equation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Mean Cumulative Count using the equation method — mcc_equation","text":"list containing MCC results. include_details = TRUE, returns complete calculation details. Otherwise, returns final MCC estimates.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_estimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract MCC estimates from mcc objects — mcc_estimates","title":"Extract MCC estimates from mcc objects — mcc_estimates","text":"Extract MCC estimates mcc objects","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_estimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract MCC estimates from mcc objects — mcc_estimates","text":"","code":"mcc_estimates(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_estimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract MCC estimates from mcc objects — mcc_estimates","text":"x mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_estimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract MCC estimates from mcc objects — mcc_estimates","text":"tibble MCC estimates","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_estimates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract MCC estimates from mcc objects — mcc_estimates","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2)  ) |>   arrange(id, time)  # Calculate MCC mcc_result <- mcc(df, \"id\", \"time\", \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Extract MCC estimates estimates <- mcc_estimates(mcc_result) print(estimates) #> # A tibble: 5 × 2 #>    time   mcc #>   <dbl> <dbl> #> 1     0  0    #> 2     2  0.25 #> 3     3  0.5  #> 4     6  0.75 #> 5     7  1     # For grouped analysis df_grouped <- df |>   mutate(group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\"))  mcc_grouped <- mcc(df_grouped, \"id\", \"time\", \"cause\", by = \"group\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. estimates_grouped <- mcc_estimates(mcc_grouped) print(estimates_grouped) #>     group  time   mcc #>    <char> <num> <num> #> 1:      A     0   0.0 #> 2:      A     3   0.5 #> 3:      B     0   0.0 #> 4:      B     2   0.5 #> 5:      B     6   1.0 #> 6:      B     7   1.5  # Clean up rm(df, df_grouped, mcc_result, mcc_grouped, estimates, estimates_grouped)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_final_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Get final MCC value for each group — mcc_final_values","title":"Get final MCC value for each group — mcc_final_values","text":"Extracts final (maximum time) MCC value group grouped analysis, overall final MCC value ungrouped analyses.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_final_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get final MCC value for each group — mcc_final_values","text":"","code":"mcc_final_values(x)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_final_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get final MCC value for each group — mcc_final_values","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_final_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get final MCC value for each group — mcc_final_values","text":"named numeric vector final MCC values","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_final_values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get final MCC value for each group — mcc_final_values","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 1, 2),   group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\") ) |>   arrange(id, time)  # Ungrouped analysis mcc_ungrouped <- mcc(df, \"id\", \"time\", \"cause\") #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> ℹ Adjusted time points for events occurring simultaneously for the same subject. mcc_final_values(mcc_ungrouped) #> Overall  #>       1   # Grouped analysis mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"group\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates mcc_final_values(mcc_grouped) #>   A   B  #> 0.5 1.5   # Clean up rm(df, mcc_ungrouped, mcc_grouped)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_grouping_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Get grouping variable name from grouped mcc object — mcc_grouping_var","title":"Get grouping variable name from grouped mcc object — mcc_grouping_var","text":"Get grouping variable name grouped mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_grouping_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get grouping variable name from grouped mcc object — mcc_grouping_var","text":"","code":"mcc_grouping_var(x)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_grouping_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get grouping variable name from grouped mcc object — mcc_grouping_var","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_grouping_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get grouping variable name from grouped mcc object — mcc_grouping_var","text":"Character string grouping variable name, NULL grouped","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_grouping_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get grouping variable name from grouped mcc object — mcc_grouping_var","text":"","code":"# Create sample data with groups library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2),   treatment = c(\"Control\", \"Control\", \"Treatment\", \"Treatment\",                 \"Treatment\", \"Treatment\", \"Treatment\", \"Control\",                 \"Control\") ) |>   arrange(id, time)  # Grouped analysis mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"treatment\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Get grouping variable name mcc_grouping_var(mcc_grouped)  # \"treatment\" #> [1] \"treatment\"  # Clean up rm(df, mcc_grouped)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract unique groups from grouped mcc object — mcc_groups","title":"Extract unique groups from grouped mcc object — mcc_groups","text":"Extract unique groups grouped mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract unique groups from grouped mcc object — mcc_groups","text":"","code":"mcc_groups(x)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract unique groups from grouped mcc object — mcc_groups","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_groups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract unique groups from grouped mcc object — mcc_groups","text":"Character vector unique group values, NULL grouped","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_groups.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract unique groups from grouped mcc object — mcc_groups","text":"","code":"# Create sample data with groups library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 5, 5, 6, 7, 8),   time = c(8, 1, 5, 2, 6, 7, 3, 3, 4, 9, 2),   cause = c(0, 0, 2, 1, 1, 1, 1, 2, 1, 0, 2),   treatment = c(\"Control\", \"Control\", \"Treatment\", \"Treatment\",                 \"Treatment\", \"Treatment\", \"Control\", \"Control\",                 \"Placebo\", \"Placebo\", \"Placebo\") ) |>   arrange(id, time)  # Grouped analysis mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"treatment\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 4 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates #> Warning: Found 1 participant where last observation is an event of interest (`cause_var` #> = 1) #> ! ID: 6 #> ℹ `mcc()` assumes these participants are censored at their final `time_var` #> ℹ If participants were actually censored or experienced competing risks after #>   their last event, add those observations to ensure correct estimates  # Get all unique groups mcc_groups(mcc_grouped)  # \"Control\", \"Placebo\", \"Treatment\" #> [1] \"Control\"   \"Treatment\" \"Placebo\"    # Clean up rm(df, mcc_grouped)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the method used for MCC calculation — mcc_method","title":"Get the method used for MCC calculation — mcc_method","text":"Get method used MCC calculation","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the method used for MCC calculation — mcc_method","text":"","code":"mcc_method(x)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the method used for MCC calculation — mcc_method","text":"x mcc object","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the method used for MCC calculation — mcc_method","text":"Character string indicating method (\"equation\" \"sci\")","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the method used for MCC calculation — mcc_method","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2),   group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\") ) |>   arrange(id, time)  # Calculate MCC mcc_result <- mcc(df, \"id\", \"time\", \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Get the method used mcc_method(mcc_result) #> [1] \"equation\"  # Clean up rm(df, mcc_result)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_sci.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Mean Cumulative Count using the Sum of Cumulative Incidence method — mcc_sci","title":"Calculate Mean Cumulative Count using the Sum of Cumulative Incidence method — mcc_sci","text":"Calculate Mean Cumulative Count using Sum Cumulative Incidence method","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_sci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Mean Cumulative Count using the Sum of Cumulative Incidence method — mcc_sci","text":"","code":"mcc_sci(   data,   id_var,   time_var,   cause_var,   tstart_var = NULL,   adjust_times = TRUE,   time_precision = 1e-06,   include_details = TRUE )"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_sci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Mean Cumulative Count using the Sum of Cumulative Incidence method — mcc_sci","text":"data data.frame tibble containing required variables id_var Name column containing participant IDs (string symbol) time_var Name column containing follow-event times (string symbol) cause_var Name column containing event indicators (string symbol) (1=event interest, 2=competing risk, 0=censoring) tstart_var Name column containing start times follow-(string symbol, optional). NULL (default), constant value 0 used observations. adjust_times Whether automatically adjust times simultaneous events (default: TRUE) time_precision Precision used adjusting simultaneous events (default: 1e-6) include_details Whether include detailed calculation tables intermediate objects output (default: TRUE).","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mcc_sci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Mean Cumulative Count using the Sum of Cumulative Incidence method — mcc_sci","text":"list containing MCC results. include_details=TRUE, returns complete calculation details. Otherwise, returns final MCC estimates.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mccount-package.html","id":null,"dir":"Reference","previous_headings":"","what":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"Calculates mean cumulative count (MCC) estimate expected cumulative number recurrent events per person time presence competing risks censoring. Implements Dong-Yasui equation method sum cumulative incidence method described Dong, et al. (2015) doi:10.1093/aje/kwu289 . Supports inverse probability weighting causal inference outlined Gaber, et al. (2023) doi:10.1093/aje/kwad031 . Provides S3 methods printing, summarizing, plotting, extracting results. Handles grouped analyses integrates 'ggplot2' https://ggplot2.tidyverse.org/ visualization.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mccount-package.html","id":"main-function","dir":"Reference","previous_headings":"","what":"Main Function","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"mcc() - estimates MCC","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mccount-package.html","id":"s-object-system","dir":"Reference","previous_headings":"","what":"S3 Object System","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"package uses S3 classes provide consistent, extensible interface: Base Class: mcc - MCC results inherit class Method-Specific Classes: mcc_equation - Results Dong-Yasui estimator mcc_sci - Results Sum Cumulative Incidence estimator Analysis-Type Classes: mcc_weighted - Results using weighting mcc_grouped - Results grouped/stratified analysis Classes combine hierarchically (e.g., c(\"mcc_grouped\", \"mcc_weighted\", \"mcc_equation\", \"mcc\")).","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mccount-package.html","id":"available-methods","dir":"Reference","previous_headings":"","what":"Available Methods","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"Generic S3 Methods: print.mcc() - Formatted display results summary.mcc() - Statistical summaries plot.mcc() - Visualization ggplot2 autoplot.mcc() - ggplot2-style plotting (ggplot2 loaded) .data.frame.mcc() - Convert standard data.frame as_mcc() - Convert objects MCC class Utility Functions: is_mcc() - Test object MCC result mcc_estimates() - Extract main results table mcc_details() - Extract calculation details mcc_method() - Get calculation method used is_weighted(), is_grouped() - Check analysis properties mcc_groups(), mcc_grouping_var() - Access grouping information filter_mcc() - Filter grouped results mcc_final_values() - Extract final MCC values compare_mcc() - Compare two MCC objects","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mccount-package.html","id":"basic-usage","dir":"Reference","previous_headings":"","what":"Basic Usage","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"","code":"# Calculate MCC result <- mcc(data, \"id\", \"time\", \"cause\")  # Examine results result              # Uses print.mcc() summary(result)     # Uses summary.mcc() plot(result)        # Uses plot.mcc()  # Extract components estimates <- mcc_estimates(result) details <- mcc_details(result) final_values <- mcc_final_values(result)  # Grouped analysis grouped_result <- mcc(data, \"id\", \"time\", \"cause\", by = \"treatment\") plot(grouped_result) filter_mcc(grouped_result, \"Treatment A\")"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mccount-package.html","id":"plotting","dir":"Reference","previous_headings":"","what":"Plotting","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"package provides flexible plotting S3 methods automatically adapt analysis type:","code":"# Basic plotting plot(mcc_result)                    # MCC over time plot(mcc_result, type = \"details\")  # Calculation components  # Customization plot(mcc_result, colors = c(\"red\", \"blue\"), title = \"Custom Title\")  # ggplot2 integration library(ggplot2) autoplot(mcc_result) + theme_classic()  # Further customization plot(mcc_result) +   geom_hline(yintercept = 1, linetype = \"dashed\") +   labs(caption = \"Dashed line at MCC = 1\")"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mccount-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"Core Methods: Dong H, Robison LL, Leisenring WM, Martin LJ, Armstrong GT, Yasui Y. Estimating burden recurrent events presence competing risks: method mean cumulative count. J Epidemiol. 2015;181(7):532-40. Weighted Extension: Gaber CE, Edwards JK, Lund JL, Peery AF, Richardson DB, Kinlaw AC. Inverse Probability Weighting Estimate Exposure Effects Burden Recurrent Outcomes Presence Competing Events. J Epidemiol. 2023;192(5):830-839.","code":""},{"path":[]},{"path":"https://kennethataylor.github.io/mccount/dev/reference/mccount-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mccount: Estimate Recurrent Event Burden with Competing Risks — mccount-package","text":"Maintainer: Kenneth . Taylor kenneth.taylor.dpt@gmail.com (ORCID) [copyright holder]","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/plot.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot MCC results — plot.mcc","title":"Plot MCC results — plot.mcc","text":"Creates plots Mean Cumulative Count (MCC) results. plotting method automatically adapts based mcc object class whether analysis grouped.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/plot.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot MCC results — plot.mcc","text":"","code":"# S3 method for class 'mcc' plot(   x,   type = c(\"mcc\", \"components\"),   groups = NULL,   conf_int = FALSE,   colors = NULL,   title = NULL,   subtitle = NULL,   ... )"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/plot.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot MCC results — plot.mcc","text":"x mcc object type Character string specifying plot type: \"mcc\" (default): Plot MCC estimates time \"components\": Show individual cumulative incidence components (SCI method ) groups Character vector specifying groups include grouped analyses. NULL (default), groups included conf_int Logical indicating whether include confidence intervals available colors Character vector colors use groups. NULL, uses default colors title Character string plot title. NULL, generates automatic title subtitle Character string plot subtitle. NULL, generates automatic subtitle ... Additional arguments passed ggplot2 functions","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/plot.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot MCC results — plot.mcc","text":"ggplot2 object","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/plot.mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot MCC results — plot.mcc","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2),   group = c(\"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"B\", \"A\", \"A\") ) |>   arrange(id, time)  # Basic MCC plot (ungrouped) mcc_result <- mcc(df, \"id\", \"time\", \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. plot(mcc_result)   # Grouped analysis with custom colors mcc_grouped <- mcc(df, \"id\", \"time\", \"cause\", by = \"group\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. plot(mcc_grouped)   # Customize the grouped plot plot(mcc_grouped,      colors = c(\"red\", \"blue\"),      title = \"MCC by Treatment Group\",      subtitle = \"Comparison of Event Burden\")   # Plot only specific groups plot(mcc_grouped, groups = c(\"A\"))   # Compare different methods - equation method only shows MCC mcc_eq <- mcc(df, \"id\", \"time\", \"cause\", method = \"equation\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. plot(mcc_eq)   # SCI method can show components of cumulative incidence components mcc_sci <- mcc(df, \"id\", \"time\", \"cause\", method = \"sci\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. plot(mcc_sci)  # Shows main MCC plot  plot(mcc_sci, type = \"components\")  # Shows CI components   # Clean up rm(df, mcc_result, mcc_grouped, mcc_eq, mcc_sci)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for mcc objects — print.mcc","title":"Print method for mcc objects — print.mcc","text":"Print method mcc objects","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for mcc objects — print.mcc","text":"","code":"# S3 method for class 'mcc' print(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for mcc objects — print.mcc","text":"x mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for mcc objects — print.mcc","text":"x invisibly","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print method for mcc objects — print.mcc","text":"","code":"# Attach dplyr library(dplyr) # Create sample data with recurrent events df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2)  ) |>   arrange(id, time)  # Sort the data by id and time  # Calculate MCC using the equation method (default) mcc_eq <- mcc(df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Print the S3 object (uses print.mcc method) mcc_eq #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time   mcc #>   <dbl> <dbl> #> 1     0  0    #> 2     2  0.25 #> 3     3  0.5  #> 4     6  0.75 #> 5     7  1    #> ── Call ── #>  #> mcc(data = df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\")  # Calculate MCC using the sum of cumulative incidence method mcc_sci <- mcc(   df,   id_var = \"id\",   time_var = \"time\",   cause_var = \"cause\",   method = \"sci\" ) #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Print the S3 object mcc_sci #>  #> ── Mean Cumulative Count Results ─────────────────────────────────────────────── #> ℹ Method: Sum of Cumulative Incidence Method #>  #> ── MCC Estimates ── #>  #> # A tibble: 5 × 2 #>    time SumCIs #>   <dbl>  <dbl> #> 1     0   0    #> 2     2   0.25 #> 3     3   0.5  #> 4     6   0.75 #> 5     7   1    #> ── Call ── #>  #> mcc(data = df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\",  #>     method = \"sci\")  # Clean up rm(df, mcc_eq, mcc_sci)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.mcc_comparison.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for MCC comparison objects — print.mcc_comparison","title":"Print method for MCC comparison objects — print.mcc_comparison","text":"Print method MCC comparison objects","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.mcc_comparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for MCC comparison objects — print.mcc_comparison","text":"","code":"# S3 method for class 'mcc_comparison' print(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.mcc_comparison.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for MCC comparison objects — print.mcc_comparison","text":"x mcc_comparison object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.mcc_comparison.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for MCC comparison objects — print.mcc_comparison","text":"x invisibly","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.mcc_comparison.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print method for MCC comparison objects — print.mcc_comparison","text":"","code":"# Create sample data library(dplyr) df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2) ) |>   arrange(id, time)  # Calculate MCC using different methods mcc_eq <- mcc(df, \"id\", \"time\", \"cause\", method = \"equation\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject. mcc_sci <- mcc(df, \"id\", \"time\", \"cause\", method = \"sci\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  # Compare the results comparison <- compare_mcc(mcc_eq, mcc_sci) print(comparison) #>  #> ── MCC Object Comparison ─────────────────────────────────────────────────────── #> ! Objects differ in one or more aspects #>  #> ── Comparison Details ── #>  #> ✖ Methods match #> ✔ Weighted status matches #> ✔ Grouping status matches #> ✔ Grouping variables match #> ✔ Final values are close #> Maximum difference in final values: 0  # Clean up rm(df, mcc_eq, mcc_sci, comparison)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.summary.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for mcc summary objects — print.summary.mcc","title":"Print method for mcc summary objects — print.summary.mcc","text":"Print method mcc summary objects","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.summary.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for mcc summary objects — print.summary.mcc","text":"","code":"# S3 method for class 'summary.mcc' print(x, ...)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.summary.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for mcc summary objects — print.summary.mcc","text":"x summary.mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.summary.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for mcc summary objects — print.summary.mcc","text":"Invisibly returns x","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/print.summary.mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print method for mcc summary objects — print.summary.mcc","text":"","code":"# Attach dplyr library(dplyr) # Create sample data with recurrent events df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2)  ) |>   arrange(id, time)  # Sort the data by id and time  # Calculate MCC using the equation method (default) mcc_eq <- mcc(df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  summary(mcc_eq) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Total participants: 5 #>  #> ── Summary Statistics ── #>  #> Observation period: [0, 8] #> Time to MCC = 1.0: 7 #> Time to maximum MCC: 7 #> MCC at end of follow-up: 1 #>  #> ── Event Count Composition  #> Events of interest: 4 #> Competing risk events: 2 #> Censoring events: 3  # Calculate MCC using the sum of cumulative incidence method mcc_sci <- mcc(   df,   id_var = \"id\",   time_var = \"time\",   cause_var = \"cause\",   method = \"sci\" ) #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  print(summary(mcc_sci)) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Sum of Cumulative Incidence Method #> ℹ Total participants: 5 #>  #> ── Summary Statistics ── #>  #> Observation period: [0, 8] #> Time to MCC = 1.0: 7 #> Time to maximum MCC: 7 #> MCC at end of follow-up: 1 #>  #> ── Event Count Composition  #> Events of interest: 4 #> Competing risk events: 2 #> Censoring events: 3  # Clean up rm(df, mcc_eq, mcc_sci)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/summary.mcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for mcc objects — summary.mcc","title":"Summary method for mcc objects — summary.mcc","text":"Summary method mcc objects","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/summary.mcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for mcc objects — summary.mcc","text":"","code":"# S3 method for class 'mcc' summary(object, ...)"},{"path":"https://kennethataylor.github.io/mccount/dev/reference/summary.mcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for mcc objects — summary.mcc","text":"object mcc object ... Additional arguments (currently unused)","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/summary.mcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for mcc objects — summary.mcc","text":"summary object class summary.mcc","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/reference/summary.mcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary method for mcc objects — summary.mcc","text":"","code":"# Attach dplyr library(dplyr) # Create sample data with recurrent events df <- data.frame(   id = c(1, 2, 3, 4, 4, 4, 4, 5, 5),   time = c(8, 1, 5, 2, 6, 7, 8, 3, 3),   cause = c(0, 0, 2, 1, 1, 1, 0, 1, 2)  ) |>   arrange(id, time)  # Sort the data by id and time  # Calculate MCC using the equation method (default) mcc_eq <- mcc(df, id_var = \"id\", time_var = \"time\", cause_var = \"cause\") #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  summary(mcc_eq) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Dong-Yasui Equation Method #> ℹ Total participants: 5 #>  #> ── Summary Statistics ── #>  #> Observation period: [0, 8] #> Time to MCC = 1.0: 7 #> Time to maximum MCC: 7 #> MCC at end of follow-up: 1 #>  #> ── Event Count Composition  #> Events of interest: 4 #> Competing risk events: 2 #> Censoring events: 3  # Calculate MCC using the sum of cumulative incidence method mcc_sci <- mcc(   df,   id_var = \"id\",   time_var = \"time\",   cause_var = \"cause\",   method = \"sci\" ) #> ℹ Adjusted time points for events occurring simultaneously for the same subject.  summary(mcc_sci) #>  #> ── Summary of Mean Cumulative Count Results ──────────────────────────────────── #> ℹ Method: Sum of Cumulative Incidence Method #> ℹ Total participants: 5 #>  #> ── Summary Statistics ── #>  #> Observation period: [0, 8] #> Time to MCC = 1.0: 7 #> Time to maximum MCC: 7 #> MCC at end of follow-up: 1 #>  #> ── Event Count Composition  #> Events of interest: 4 #> Competing risk events: 2 #> Censoring events: 3  # Clean up rm(df, mcc_eq, mcc_sci)"},{"path":"https://kennethataylor.github.io/mccount/dev/news/index.html","id":"mccount-development-version","dir":"Changelog","previous_headings":"","what":"mccount (development version)","title":"mccount (development version)","text":"Minor edits vignette(\"estimating-mcc--matching--weighting\")","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/news/index.html","id":"mccount-011","dir":"Changelog","previous_headings":"","what":"mccount 0.1.1","title":"mccount 0.1.1","text":"CRAN release: 2025-11-13 Removed \\dontrun{} plot function examples response CRAN review updated documentation preemptively.","code":""},{"path":"https://kennethataylor.github.io/mccount/dev/news/index.html","id":"mccount-010","dir":"Changelog","previous_headings":"","what":"mccount 0.1.0","title":"mccount 0.1.0","text":"Initial CRAN submission.","code":""}]
